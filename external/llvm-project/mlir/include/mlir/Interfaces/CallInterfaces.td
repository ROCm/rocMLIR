//===- CallInterfaces.td - Call Interfaces for ops ---------*- tablegen -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file contains a set of interfaces that can be used to define information
// related to call-like and callable operations. Each of which are defined along
// with the respective interface below.
//
//===----------------------------------------------------------------------===//

#ifndef MLIR_INTERFACES_CALLINTERFACES
#define MLIR_INTERFACES_CALLINTERFACES

include "mlir/IR/OpBase.td"

// `CallInterfaceCallable`: This is a type used to represent a single callable
// region. A callable is either a symbol, or an SSA value, that is referenced by
// a call-like operation. This represents the destination of the call.

/// Interface for call-like operations.
def CallOpInterface : OpInterface<"CallOpInterface"> {
  let description = [{
    A call-like operation is one that transfers control from one sub-routine to
    another. These operations may be traditional direct calls `call @foo`, or
    indirect calls to other operations `call_indirect %foo`. An operation that
    uses this interface, must *not* also provide the `CallableOpInterface`.
  }];
  let cppNamespace = "::mlir";

  let methods = [
    InterfaceMethod<
      /*desc=*/[{
        Clone the current call-like operation with the given attributes but
        re-assign operands and result-types. Used in bufferization for result
        buffers.
      }],
      /*retTy=*/"Operation *",
      /*methodName=*/"clone",
      /*args=*/(ins "OpBuilder &":$b, "Location":$loc, "TypeRange":$resultTypes,
                    "ValueRange":$operands),
      /*methodBody=*/[{
        BlockAndValueMapping bvm;
        OperationState state(
          loc, ConcreteOp::getOperationName(), operands, resultTypes,
          $_op->getAttrs());
        auto op = b.create(state);
        CallOpInterface callIF(op);
        callIF.updateSegmentSizes(b.getContext());
        return op;
      }]
    >,
    InterfaceMethod<
      /*desc*/[{
        Returns the callee of this call-like operation. A `callee` is either a
        reference to a symbol, via SymbolRefAttr, or a reference to a defined
        SSA value. If the reference is an SSA value, the SSA value corresponds
        to a region of a lambda-like operation.
      }], "::mlir::CallInterfaceCallable", "getCallableForCallee"
    >,
    InterfaceMethod<
      /*desc=*/[{
        Returns the operands within this call that are used as arguments to the
        callee.
      }],
      "::mlir::Operation::operand_range", "getCallOperands"
    >,
    InterfaceMethod<
      /*desc=*/[{
        Returns the results for this call that are returned by the callee.
      }],
      /*retTy=*/"::mlir::Operation::result_range",
      /*methodName=*/"getCallResults",
      /*args=*/(ins),
      /*methodBody=*/"",
      /*defaultImplementation=*/[{
        return $_op->getResults();
      }]
    >,
    InterfaceMethod<
      /*desc=*/[{
        Returns the result types for this call that are returned by the callee.
      }],
      /*retTy=*/"::mlir::Operation::result_type_range",
      /*methodName=*/"getCallResultTypes",
      /*args=*/(ins),
      /*methodBody=*/"",
      /*defaultImplementation=*/[{
        return $_op->getResultTypes();
      }]
    >,
    InterfaceMethod<
      /*desc=*/[{
        Update the operand_segment_sizes attribute for changes to operands.
      }],
      /*retTy=*/"void",
      /*methodName=*/"updateSegmentSizes",
      /*args=*/(ins "::mlir::MLIRContext *":$context),
      /*methodBody=*/"",
      /*defaultImplementation=*/[{
        assert(!$_op->hasAttr("operand_segment_sizes") &&
               !$_op->hasAttr("result_segment_sizes"));
      }]
    >,
  ];

  let extraClassDeclaration = [{
    /// Resolve the callable operation for given callee to a
    /// CallableOpInterface, or nullptr if a valid callable was not resolved.
    /// `symbolTable` is an optional parameter that will allow for using a
    /// cached symbol table for symbol lookups instead of performing an O(N)
    /// scan.
    Operation *resolveCallable(SymbolTableCollection *symbolTable = nullptr);
  }];
}

/// Interface for callable operations.
def CallableOpInterface : OpInterface<"CallableOpInterface"> {
  let description = [{
    A callable operation is one who represents a potential sub-routine, and may
    be a target for a call-like operation (those providing the CallOpInterface
    above). These operations may be traditional functional operation
    `func @foo(...)`, as well as function producing operations
    `%foo = dialect.create_function(...)`. These operations may only contain a
    single region, or subroutine.
  }];
  let cppNamespace = "::mlir";

  let methods = [
    InterfaceMethod<[{
        Returns the region on the current operation that is callable. This may
        return null in the case of an external callable object, e.g. an external
        function.
      }],
      "::mlir::Region *", "getCallableRegion"
    >,
    InterfaceMethod<[{
        Returns the results types that the callable region produces when
        executed.
      }],
      "::llvm::ArrayRef<::mlir::Type>", "getCallableResults"
    >,
  ];
}

#endif // MLIR_INTERFACES_CALLINTERFACES
