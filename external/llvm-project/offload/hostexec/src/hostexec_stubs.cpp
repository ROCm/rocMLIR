///
///  hostexec_stubs.cpp: definitions of device stubs
///
// GPUs typically do not support vargs style functions.  So to implement
// printf or any vargs function as a hostexec service requires the compiler
// to generate code to allocate a buffer, fill the buffer with the value of
// each argument, and then call a stub to execute the service with a pointer to
// the buffer. The clang compiler does this in the CGGPUBuiltin.cpp source.
// Here we define printf_allocate and printf_execute device functions that are
// generated by the clang compiler when it encounters a printf statement.
// printf_allocate is implemented as a hostexec stub. We assume that the
// host routine for printf_execute will free the buffer that was allocated
// by printf_allocate.

#include "hostexec_internal.h"
#include <stdint.h>
#include <stdio.h>
#include "Platform.h"

#pragma omp declare target

// #pragma omp begin declare variant match(device = {kind(gpu)})

typedef struct hostexec_result_s {
  uint64_t arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7;
} hostexec_result_t;

extern "C" __attribute__((noinline)) hostexec_result_t
hostexec_invoke(const uint32_t id, uint64_t arg0, uint64_t arg1, uint64_t arg2,
                uint64_t arg3, uint64_t arg4, uint64_t arg5, uint64_t arg6,
                uint64_t arg7);

static __attribute__((flatten, always_inline)) hostexec_result_t
hostexec_invoke_zeros(const uint32_t id, uint64_t arg0 = 0, uint64_t arg1 = 0,
                      uint64_t arg2 = 0, uint64_t arg3 = 0, uint64_t arg4 = 0,
                      uint64_t arg5 = 0, uint64_t arg6 = 0, uint64_t arg7 = 0) {
  return hostexec_invoke(id, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
}

extern "C" {
// This definition of __ockl_devmem_request and __ockl_sanitizer_report needs to
// override the weak symbol for __ockl_devmem_request and
// __ockl_sanitizer_report in rocm device lib ockl.bc because ockl uses
// hostcall but OpenMP uses hostexec.
__attribute__((noinline)) uint64_t __ockl_devmem_request(uint64_t addr,
                                                         uint64_t size) {
  uint64_t arg0;
  if (size) { // allocation request
    arg0 = size;
    hostexec_result_t result =
        hostexec_invoke_zeros(PACK_VERS(HOSTEXEC_SID_DEVICE_MALLOC), arg0);
    return result.arg1;
  } else { // free request
    arg0 = addr;
    hostexec_result_t result =
        hostexec_invoke_zeros(PACK_VERS(HOSTEXEC_SID_FREE), arg0);
    return result.arg0;
  }
}

__attribute__((noinline)) void
__ockl_sanitizer_report(uint64_t addr, uint64_t pc, uint64_t wgidx,
                        uint64_t wgidy, uint64_t wgidz, uint64_t wave_id,
                        uint64_t is_read, uint64_t access_size) {
  hostexec_result_t result =
      hostexec_invoke(PACK_VERS(HOSTEXEC_SID_SANITIZER), addr, pc, wgidx, wgidy,
                      wgidz, wave_id, is_read, access_size);
}
void f90print_(char *s) { printf("%s\n", s); }
void f90printi_(char *s, int *i) { printf("%s %d\n", s, *i); }
void f90printl_(char *s, long *i) { printf("%s %ld\n", s, *i); }
void f90printf_(char *s, float *f) { printf("%s %f\n", s, *f); }
void f90printd_(char *s, double *d) { printf("%s %g\n", s, *d); }

char *printf_allocate(uint32_t bufsz) {
  uint64_t arg0 = (uint64_t)bufsz;
  hostexec_result_t result =
      hostexec_invoke_zeros(PACK_VERS(HOSTEXEC_SID_HOST_MALLOC), arg0);
  return (char *)result.arg1;
}
int printf_execute(char *print_buffer, uint32_t bufsz) {
  uint64_t arg0, arg1;
  arg0 = (uint64_t)bufsz;
  arg1 = (uint64_t)print_buffer;
  hostexec_result_t result =
      hostexec_invoke_zeros(PACK_VERS(HOSTEXEC_SID_PRINTF), arg0, arg1);
  return (int)result.arg0;
}

char *hostexec_allocate(uint32_t bufsz) {
  uint64_t arg0 = (uint64_t)bufsz;
  hostexec_result_t result =
      hostexec_invoke_zeros(PACK_VERS(HOSTEXEC_SID_HOST_MALLOC), arg0);
  return (char *)result.arg1;
}

char *hostexec_uint_allocate(uint32_t bufsz) {
  return hostexec_allocate(bufsz);
}
char *hostexec_uint64_allocate(uint32_t bufsz) {
  return hostexec_allocate(bufsz);
}
char *hostexec_fortrt_allocate(uint32_t bufsz) {
  return hostexec_allocate(bufsz);
}
char *hostexec_int_allocate(uint32_t bufsz) { return hostexec_allocate(bufsz); }
char *hostexec_long_allocate(uint32_t bufsz) {
  return hostexec_allocate(bufsz);
}
char *hostexec_double_allocate(uint32_t bufsz) {
  return hostexec_allocate(bufsz);
}
char *hostexec_float_allocate(uint32_t bufsz) {
  return hostexec_allocate(bufsz);
}

char *fprintf_allocate(uint32_t bufsz) {
  uint64_t arg0 = (uint64_t)bufsz;
  hostexec_result_t result =
      hostexec_invoke_zeros(PACK_VERS(HOSTEXEC_SID_HOST_MALLOC), arg0);
  return (char *)result.arg1;
}
int fprintf_execute(char *print_buffer, uint32_t bufsz) {
  uint64_t arg0, arg1;
  arg0 = (uint64_t)bufsz;
  arg1 = (uint64_t)print_buffer;
  hostexec_result_t result =
      hostexec_invoke_zeros(PACK_VERS(HOSTEXEC_SID_FPRINTF), arg0, arg1);
  return (int)result.arg0;
}

#if 0
uint64_t __tgt_fort_ptr_assn_i8(void *varg0, void *varg1, void *varg2,
                                void *varg3, void *varg4) {
  uint64_t arg0, arg1, arg2, arg3, arg4;
  arg0 = (uint64_t)varg0;
  arg1 = (uint64_t)varg1;
  arg2 = (uint64_t)varg2;
  arg3 = (uint64_t)varg3;
  arg4 = (uint64_t)varg4;
  hostexec_result_t result = hostexec_invoke_zeros(
      PACK_VERS(HOSTEXEC_SID_FTNASSIGN), arg0, arg1, arg2, arg3, arg4);
  return (uint64_t)result.arg0;
}
#endif

void hostexec_execute(char *print_buffer, uint32_t bufsz) {
  uint64_t arg0, arg1;
  arg0 = (uint64_t)bufsz;
  arg1 = (uint64_t)print_buffer;
  hostexec_result_t result =
      hostexec_invoke_zeros(PACK_VERS(HOSTEXEC_SID_VOID), arg0, arg1);
  // hostexec() is a user-callable void function that returns nothing.
  return;
}
uint32_t hostexec_uint_execute(char *print_buffer, uint32_t bufsz) {
  uint64_t arg0, arg1;
  arg0 = (uint64_t)bufsz;
  arg1 = (uint64_t)print_buffer;
  hostexec_result_t result =
      hostexec_invoke_zeros(PACK_VERS(HOSTEXEC_SID_UINT), arg0, arg1);
  return (uint32_t)result.arg0;
}
uint64_t hostexec_uint64_execute(char *print_buffer, uint32_t bufsz) {
  uint64_t arg0, arg1;
  arg0 = (uint64_t)bufsz;
  arg1 = (uint64_t)print_buffer;
  hostexec_result_t result =
      hostexec_invoke_zeros(PACK_VERS(HOSTEXEC_SID_UINT64), arg0, arg1);
  return (uint64_t)result.arg0;
}
uint64_t hostexec_fortrt_execute(char *print_buffer, uint32_t bufsz) {
  uint64_t arg0, arg1;
  arg0 = (uint64_t)bufsz;
  arg1 = (uint64_t)print_buffer;
  hostexec_result_t result =
      hostexec_invoke_zeros(PACK_VERS(HOSTEXEC_SID_FORTRT), arg0, arg1);
  return (uint64_t)result.arg0;
}
double hostexec_double_execute(char *print_buffer, uint32_t bufsz) {
  uint64_t arg0, arg1;
  arg0 = (uint64_t)bufsz;
  arg1 = (uint64_t)print_buffer;
  hostexec_result_t result =
      hostexec_invoke_zeros(PACK_VERS(HOSTEXEC_SID_DOUBLE), arg0, arg1);
  union {
    uint64_t val;
    double dval;
  } unionarg;
  unionarg.val = result.arg0;
  return unionarg.dval;
}
int hostexec_int_execute(char *print_buffer, uint32_t bufsz) {
  uint64_t arg0, arg1;
  arg0 = (uint64_t)bufsz;
  arg1 = (uint64_t)print_buffer;
  hostexec_result_t result =
      hostexec_invoke_zeros(PACK_VERS(HOSTEXEC_SID_INT), arg0, arg1);
  return (int)result.arg0;
}
float hostexec_float_execute(char *print_buffer, uint32_t bufsz) {
  uint64_t arg0, arg1;
  arg0 = (uint64_t)bufsz;
  arg1 = (uint64_t)print_buffer;
  hostexec_result_t result =
      hostexec_invoke_zeros(PACK_VERS(HOSTEXEC_SID_FLOAT), arg0, arg1);
  union {
    float fval[2];
    uint64_t val;
  } unionarg;
  unionarg.val = result.arg0;
  return unionarg.fval[0];
}
long hostexec_long_execute(char *print_buffer, uint32_t bufsz) {
  uint64_t arg0, arg1;
  arg0 = (uint64_t)bufsz;
  arg1 = (uint64_t)print_buffer;
  hostexec_result_t result =
      hostexec_invoke_zeros(PACK_VERS(HOSTEXEC_SID_LONG), arg0, arg1);
  return (long)result.arg0;
}

// Keep these declarations in sync with the ones in DeviceRTL/src/State.cpp
// See https://github.com/llvm/llvm-project/issues/63597
__attribute__((noinline)) extern "C" uint64_t __ockl_dm_alloc(uint64_t bufsz);
__attribute__((noinline)) extern "C" void __ockl_dm_dealloc(uint64_t ptr);

// FIXME: Deprecate upstream, change test cases to use malloc & free directly
__attribute__((flatten, always_inline)) char *global_allocate(uint32_t bufsz) {
  return (char *)__ockl_dm_alloc(bufsz);
}
__attribute__((flatten, always_inline)) int global_free(void *ptr) {
  __ockl_dm_dealloc((uint64_t)ptr);
  return 0;
}

// This function is used for printf arguments that are variable length strings
// The clang compiler will generate calls to this only when a string length is
// not a compile time constant.
uint32_t __strlen_max(char *instr, uint32_t maxstrlen) {
  for (uint32_t i = 0; i < maxstrlen; i++)
    if (instr[i] == (char)0)
      return (uint32_t)(i + 1);
  return maxstrlen;
}

#if defined(__NVPTX__) || defined(__AMDGCN__)
// These are function definitions of selected fortran device runtime functions
// that will be executed on the host using hostexec. The host functions
// that implement the service are defined in services/execute_service.cpp.
// These functions begin with V_ because they are variadic functions.
// Variadic functions make it easy to reconstruct the exact arguments for
// the call to the actual fortran host runtime function.

// Since these variadic functions are static functions in execute_service.cpp,
// we only send the index from the enum set of known functions as a fake
// function pointer in the first arg. See the switch(DeviceRuntime_idx) in
// execute_service.cpp which determins the correct function pointer to
// the V_ function based on this index.
//
// Note that eventually these device fortran runtime functions definitions
// will be moved to flang/runtime under the same #if above as the
// device alternative to the host version of the functions. This will
// require hostexec to be available.

uint32_t omp_get_thread_num();
uint32_t omp_get_num_threads();
uint32_t omp_get_team_num();
uint32_t omp_get_num_teams();

#define _EXTRA_ARGS                                                            \
  omp_get_thread_num(), omp_get_num_threads(), omp_get_team_num(),             \
      omp_get_num_teams()
void *_FortranAioBeginExternalListOutput(uint32_t a1, const char *a2,
                                         uint32_t a3) {
  void *cookie = (void *)hostexec_fortrt(
      (void *)_FortranAioBeginExternalListOutput_idx, _EXTRA_ARGS, a1, a2, a3);
  return cookie;
}
bool _FortranAioOutputAscii(void *a1, char *a2, uint64_t a3) {
  // TODO: must use string length from a3 arg
  a2[a3 - 1] = (char)0; // loose a char, till we create hostexec_charlen_arg
                        // that gets length from subsequent arg
  return (bool)hostexec_fortrt((void *)_FortranAioOutputAscii_idx, _EXTRA_ARGS,
                               a1, a2, a3);
}
bool _FortranAioOutputInteger32(void *a1, uint32_t a2) {
  return (bool)hostexec_fortrt((void *)_FortranAioOutputInteger32_idx,
                               _EXTRA_ARGS, a1, a2);
}
uint32_t _FortranAioEndIoStatement(void *a1) {
  return (uint32_t)hostexec_fortrt((void *)_FortranAioEndIoStatement_idx,
                                   _EXTRA_ARGS, a1);
}
bool _FortranAioOutputInteger8(void *cookie, int8_t n) {
  return (bool)hostexec_fortrt((void *)_FortranAioOutputInteger8_idx,
                               _EXTRA_ARGS, cookie, n);
}
bool _FortranAioOutputInteger16(void *cookie, int16_t n) {
  return (bool)hostexec_fortrt((void *)_FortranAioOutputInteger16_idx,
                               _EXTRA_ARGS, cookie, n);
}
bool _FortranAioOutputInteger64(void *cookie, int64_t n) {
  return (bool)hostexec_fortrt((void *)_FortranAioOutputInteger64_idx,
                               _EXTRA_ARGS, cookie, n);
}
bool _FortranAioOutputReal32(void *cookie, float x) {
  return (bool)hostexec_fortrt((void *)_FortranAioOutputReal32_idx, _EXTRA_ARGS,
                               cookie, x);
}
bool _FortranAioOutputReal64(void *cookie, double x) {
  return (bool)hostexec_fortrt((void *)_FortranAioOutputReal64_idx, _EXTRA_ARGS,
                               cookie, x);
}
bool _FortranAioOutputComplex32(void *cookie, float re, float im) {
  return (bool)hostexec_fortrt((void *)_FortranAioOutputComplex32_idx,
                               _EXTRA_ARGS, cookie, re, im);
}
bool _FortranAioOutputComplex64(void *cookie, double re, double im) {
  return (bool)hostexec_fortrt((void *)_FortranAioOutputComplex64_idx,
                               _EXTRA_ARGS, cookie, re, im);
}
bool _FortranAioOutputLogical(void *cookie, bool barg) {
  return (bool)hostexec_fortrt((void *)_FortranAioOutputLogical_idx,
                               _EXTRA_ARGS, cookie, barg);
}
void _FortranAAbort() {
  hostexec_fortrt((void *)_FortranAAbort_idx);
  // When  host service _FortranAAbort finishes, we must die from the device.
  __builtin_trap();
}
void _FortranAStopStatementText(char *errmsg, int64_t a1, bool a2, bool a3) {
  // TODO: must use string length from a1 arg
  errmsg[a1 - 1] = (char)0;
  hostexec_fortrt((void *)_FortranAStopStatementText_idx, errmsg, a1, a2, a3);
  __builtin_trap();
}
#endif

} // end extern "C"
#pragma omp end declare target
#undef _EXTRA_ARGS
