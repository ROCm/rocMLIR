///
///  hostexec_stubs.cpp: definitions of device stubs
///
// GPUs typically do not support vargs style functions.  So to implement
// printf or any vargs function as a hostexec service requires the compiler
// to generate code to allocate a buffer, fill the buffer with the value of
// each argument, and then call a stub to execute the service with a pointer to
// the buffer. The clang compiler does this in the CGGPUBuiltin.cpp source.
// Here we define printf_allocate and printf_execute device functions that are
// generated by the clang compiler when it encounters a printf statement.
// printf_allocate is implemented as a hostexec stub. We assume that the
// host routine for printf_execute will free the buffer that was allocated
// by printf_allocate.

#include "hostexec_internal.h"
#include <stdint.h>
#include <stdio.h>

#pragma omp declare target

// #pragma omp begin declare variant match(device = {kind(gpu)})

typedef struct hostexec_result_s {
  uint64_t arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7;
} hostexec_result_t;

extern "C" __attribute__((noinline)) hostexec_result_t
hostexec_invoke(const uint32_t id, uint64_t arg0, uint64_t arg1, uint64_t arg2,
                uint64_t arg3, uint64_t arg4, uint64_t arg5, uint64_t arg6,
                uint64_t arg7);

static __attribute__((flatten, always_inline)) hostexec_result_t
hostexec_invoke_zeros(const uint32_t id, uint64_t arg0 = 0, uint64_t arg1 = 0,
                      uint64_t arg2 = 0, uint64_t arg3 = 0, uint64_t arg4 = 0,
                      uint64_t arg5 = 0, uint64_t arg6 = 0, uint64_t arg7 = 0) {
  return hostexec_invoke(id, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
}

extern "C" {
// This definition of __ockl_devmem_request and __ockl_sanitizer_report needs to
// override the weak symbol for __ockl_devmem_request and
// __ockl_sanitizer_report in rocm device lib ockl.bc because ockl uses
// hostcall but OpenMP uses hostexec.
__attribute__((noinline)) uint64_t __ockl_devmem_request(uint64_t addr,
                                                         uint64_t size) {
  uint64_t arg0;
  if (size) { // allocation request
    arg0 = size;
    hostexec_result_t result =
        hostexec_invoke_zeros(PACK_VERS(HOSTEXEC_SID_DEVICE_MALLOC), arg0);
    return result.arg1;
  } else { // free request
    arg0 = addr;
    hostexec_result_t result =
        hostexec_invoke_zeros(PACK_VERS(HOSTEXEC_SID_FREE), arg0);
    return result.arg0;
  }
}

__attribute__((noinline)) void
__ockl_sanitizer_report(uint64_t addr, uint64_t pc, uint64_t wgidx,
                        uint64_t wgidy, uint64_t wgidz, uint64_t wave_id,
                        uint64_t is_read, uint64_t access_size) {
  hostexec_result_t result =
      hostexec_invoke(PACK_VERS(HOSTEXEC_SID_SANITIZER), addr, pc, wgidx, wgidy,
                      wgidz, wave_id, is_read, access_size);
}
void f90print_(char *s) { printf("%s\n", s); }
void f90printi_(char *s, int *i) { printf("%s %d\n", s, *i); }
void f90printl_(char *s, long *i) { printf("%s %ld\n", s, *i); }
void f90printf_(char *s, float *f) { printf("%s %f\n", s, *f); }
void f90printd_(char *s, double *d) { printf("%s %g\n", s, *d); }

char *printf_allocate(uint32_t bufsz) {
  uint64_t arg0 = (uint64_t)bufsz;
  hostexec_result_t result =
      hostexec_invoke_zeros(PACK_VERS(HOSTEXEC_SID_HOST_MALLOC), arg0);
  return (char *)result.arg1;
}
int printf_execute(char *print_buffer, uint32_t bufsz) {
  uint64_t arg0, arg1;
  arg0 = (uint64_t)bufsz;
  arg1 = (uint64_t)print_buffer;
  hostexec_result_t result =
      hostexec_invoke_zeros(PACK_VERS(HOSTEXEC_SID_PRINTF), arg0, arg1);
  return (int)result.arg0;
}

char *hostexec_allocate(uint32_t bufsz) {
  uint64_t arg0 = (uint64_t)bufsz;
  hostexec_result_t result =
      hostexec_invoke_zeros(PACK_VERS(HOSTEXEC_SID_HOST_MALLOC), arg0);
  return (char *)result.arg1;
}

char *hostexec_uint_allocate(uint32_t bufsz) {
  return hostexec_allocate(bufsz);
}
char *hostexec_uint64_allocate(uint32_t bufsz) {
  return hostexec_allocate(bufsz);
}
char *hostexec_int_allocate(uint32_t bufsz) { return hostexec_allocate(bufsz); }
char *hostexec_long_allocate(uint32_t bufsz) {
  return hostexec_allocate(bufsz);
}
char *hostexec_double_allocate(uint32_t bufsz) {
  return hostexec_allocate(bufsz);
}
char *hostexec_float_allocate(uint32_t bufsz) {
  return hostexec_allocate(bufsz);
}

char *fprintf_allocate(uint32_t bufsz) {
  uint64_t arg0 = (uint64_t)bufsz;
  hostexec_result_t result =
      hostexec_invoke_zeros(PACK_VERS(HOSTEXEC_SID_HOST_MALLOC), arg0);
  return (char *)result.arg1;
}
int fprintf_execute(char *print_buffer, uint32_t bufsz) {
  uint64_t arg0, arg1;
  arg0 = (uint64_t)bufsz;
  arg1 = (uint64_t)print_buffer;
  hostexec_result_t result =
      hostexec_invoke_zeros(PACK_VERS(HOSTEXEC_SID_FPRINTF), arg0, arg1);
  return (int)result.arg0;
}

#if 0
uint64_t __tgt_fort_ptr_assn_i8(void *varg0, void *varg1, void *varg2,
                                void *varg3, void *varg4) {
  uint64_t arg0, arg1, arg2, arg3, arg4;
  arg0 = (uint64_t)varg0;
  arg1 = (uint64_t)varg1;
  arg2 = (uint64_t)varg2;
  arg3 = (uint64_t)varg3;
  arg4 = (uint64_t)varg4;
  hostexec_result_t result = hostexec_invoke_zeros(
      PACK_VERS(HOSTEXEC_SID_FTNASSIGN), arg0, arg1, arg2, arg3, arg4);
  return (uint64_t)result.arg0;
}
#endif

void hostexec_execute(char *print_buffer, uint32_t bufsz) {
  uint64_t arg0, arg1;
  arg0 = (uint64_t)bufsz;
  arg1 = (uint64_t)print_buffer;
  hostexec_result_t result =
      hostexec_invoke_zeros(PACK_VERS(HOSTEXEC_SID_VOID), arg0, arg1);
  // hostexec() is a user-callable void function that returns nothing.
  return;
}
uint32_t hostexec_uint_execute(char *print_buffer, uint32_t bufsz) {
  uint64_t arg0, arg1;
  arg0 = (uint64_t)bufsz;
  arg1 = (uint64_t)print_buffer;
  hostexec_result_t result =
      hostexec_invoke_zeros(PACK_VERS(HOSTEXEC_SID_UINT), arg0, arg1);
  return (uint32_t)result.arg0;
}
uint64_t hostexec_uint64_execute(char *print_buffer, uint32_t bufsz) {
  uint64_t arg0, arg1;
  arg0 = (uint64_t)bufsz;
  arg1 = (uint64_t)print_buffer;
  hostexec_result_t result =
      hostexec_invoke_zeros(PACK_VERS(HOSTEXEC_SID_UINT64), arg0, arg1);
  return (uint64_t)result.arg0;
}
double hostexec_double_execute(char *print_buffer, uint32_t bufsz) {
  uint64_t arg0, arg1;
  arg0 = (uint64_t)bufsz;
  arg1 = (uint64_t)print_buffer;
  hostexec_result_t result =
      hostexec_invoke_zeros(PACK_VERS(HOSTEXEC_SID_DOUBLE), arg0, arg1);
  union {
    uint64_t val;
    double dval;
  } unionarg;
  unionarg.val = result.arg0;
  return unionarg.dval;
}
int hostexec_int_execute(char *print_buffer, uint32_t bufsz) {
  uint64_t arg0, arg1;
  arg0 = (uint64_t)bufsz;
  arg1 = (uint64_t)print_buffer;
  hostexec_result_t result =
      hostexec_invoke_zeros(PACK_VERS(HOSTEXEC_SID_INT), arg0, arg1);
  return (int)result.arg0;
}
float hostexec_float_execute(char *print_buffer, uint32_t bufsz) {
  uint64_t arg0, arg1;
  arg0 = (uint64_t)bufsz;
  arg1 = (uint64_t)print_buffer;
  hostexec_result_t result =
      hostexec_invoke_zeros(PACK_VERS(HOSTEXEC_SID_FLOAT), arg0, arg1);
  union {
    float fval[2];
    uint64_t val;
  } unionarg;
  unionarg.val = result.arg0;
  return unionarg.fval[0];
}
long hostexec_long_execute(char *print_buffer, uint32_t bufsz) {
  uint64_t arg0, arg1;
  arg0 = (uint64_t)bufsz;
  arg1 = (uint64_t)print_buffer;
  hostexec_result_t result =
      hostexec_invoke_zeros(PACK_VERS(HOSTEXEC_SID_LONG), arg0, arg1);
  return (long)result.arg0;
}

// Keep these declarations in sync with the ones in DeviceRTL/src/State.cpp
// See https://github.com/llvm/llvm-project/issues/63597
extern "C" uint64_t __ockl_dm_alloc(uint64_t bufsz);
extern "C" void __ockl_dm_dealloc(uint64_t ptr);

// FIXME: Deprecate upstream, change test cases to use malloc & free directly
__attribute__((flatten, always_inline)) char *global_allocate(uint32_t bufsz) {
  return (char *)__ockl_dm_alloc(bufsz);
}
__attribute__((flatten, always_inline)) int global_free(void *ptr) {
  __ockl_dm_dealloc((uint64_t)ptr);
  return 0;
}

// This function is used for printf arguments that are variable length strings
// The clang compiler will generate calls to this only when a string length is
// not a compile time constant.
uint32_t __strlen_max(char *instr, uint32_t maxstrlen) {
  for (uint32_t i = 0; i < maxstrlen; i++)
    if (instr[i] == (char)0)
      return (uint32_t)(i + 1);
  return maxstrlen;
}

} // end extern "C"

#pragma omp end declare target
