Common subdirectories: /zyin/IR-release/CMakeFiles and /zyin/IR-patch/CMakeFiles
Only in /zyin/IR-release: LinalgNamedStructuredOps.tcgen.cpp.inc
Only in /zyin/IR-release: LinalgNamedStructuredOps.tcgen.td
diff --color /zyin/IR-release/LinalgStructuredOps.cpp.inc /zyin/IR-patch/LinalgStructuredOps.cpp.inc
32d31
< ::mlir::linalg::MatmulI8I8I32Op,
6124,6374d6122
< 
< namespace mlir {
< namespace linalg {
< 
< //===----------------------------------------------------------------------===//
< // ::mlir::linalg::MatmulI8I8I32Op definitions
< //===----------------------------------------------------------------------===//
< 
< MatmulI8I8I32OpAdaptor::MatmulI8I8I32OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {
< 
< }
< 
< MatmulI8I8I32OpAdaptor::MatmulI8I8I32OpAdaptor(MatmulI8I8I32Op&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {
< 
< }
< 
< ::mlir::ValueRange MatmulI8I8I32OpAdaptor::getOperands() {
<   return odsOperands;
< }
< 
< std::pair<unsigned, unsigned> MatmulI8I8I32OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
<   assert(odsAttrs && "missing segment size attribute for op");
<   auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
< 
<   const uint32_t *sizeAttrValueIt = &*sizeAttr.value_begin<uint32_t>();
<   if (sizeAttr.isSplat())
<     return {*sizeAttrValueIt * index, *sizeAttrValueIt};
< 
<   unsigned start = 0;
<   for (unsigned i = 0; i < index; ++i)
<     start += sizeAttrValueIt[i];
<   return {start, sizeAttrValueIt[index]};
< }
< 
< ::mlir::ValueRange MatmulI8I8I32OpAdaptor::getODSOperands(unsigned index) {
<   auto valueRange = getODSOperandIndexAndLength(index);
<   return {std::next(odsOperands.begin(), valueRange.first),
<            std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
< }
< 
< ::mlir::ValueRange MatmulI8I8I32OpAdaptor::inputs() {
<   return getODSOperands(0);
< }
< 
< ::mlir::ValueRange MatmulI8I8I32OpAdaptor::outputs() {
<   return getODSOperands(1);
< }
< 
< ::mlir::DictionaryAttr MatmulI8I8I32OpAdaptor::getAttributes() {
<   return odsAttrs;
< }
< 
< ::mlir::RegionRange MatmulI8I8I32OpAdaptor::getRegions() {
<   return odsRegions;
< }
< 
< ::mlir::Region &MatmulI8I8I32OpAdaptor::region() {
<   return *odsRegions[0];
< }
< 
< ::mlir::LogicalResult MatmulI8I8I32OpAdaptor::verify(::mlir::Location loc) {
<   {
<     auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
<     auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
<     if (numElements != 2)
<       return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
<                        "must have 2 elements, but got ") << numElements;
<   }
<     return ::mlir::success();
< }
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< std::pair<unsigned, unsigned> MatmulI8I8I32Op::getODSOperandIndexAndLength(unsigned index) {
<   auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();
< 
<   const uint32_t *sizeAttrValueIt = &*sizeAttr.value_begin<uint32_t>();
<   if (sizeAttr.isSplat())
<     return {*sizeAttrValueIt * index, *sizeAttrValueIt};
< 
<   unsigned start = 0;
<   for (unsigned i = 0; i < index; ++i)
<     start += sizeAttrValueIt[i];
<   return {start, sizeAttrValueIt[index]};
< }
< 
< ::mlir::Operation::operand_range MatmulI8I8I32Op::getODSOperands(unsigned index) {
<   auto valueRange = getODSOperandIndexAndLength(index);
<   return {std::next(getOperation()->operand_begin(), valueRange.first),
<            std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
< }
< 
< ::mlir::Operation::operand_range MatmulI8I8I32Op::inputs() {
<   return getODSOperands(0);
< }
< 
< ::mlir::Operation::operand_range MatmulI8I8I32Op::outputs() {
<   return getODSOperands(1);
< }
< 
< ::mlir::MutableOperandRange MatmulI8I8I32Op::inputsMutable() {
<   auto range = getODSOperandIndexAndLength(0);
<   auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
<   return mutableRange;
< }
< 
< ::mlir::MutableOperandRange MatmulI8I8I32Op::outputsMutable() {
<   auto range = getODSOperandIndexAndLength(1);
<   auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
<   return mutableRange;
< }
< 
< std::pair<unsigned, unsigned> MatmulI8I8I32Op::getODSResultIndexAndLength(unsigned index) {
<   bool isVariadic[] = {true};
<   int prevVariadicCount = 0;
<   for (unsigned i = 0; i < index; ++i)
<     if (isVariadic[i]) ++prevVariadicCount;
< 
<   // Calculate how many dynamic values a static variadic operand corresponds to.
<   // This assumes all static variadic operands have the same dynamic value count.
<   int variadicSize = (getOperation()->getNumResults() - 0) / 1;
<   // `index` passed in as the parameter is the static index which counts each
<   // operand (variadic or not) as size 1. So here for each previous static variadic
<   // operand, we need to offset by (variadicSize - 1) to get where the dynamic
<   // value pack for this static operand starts.
<   int start = index + (variadicSize - 1) * prevVariadicCount;
<   int size = isVariadic[index] ? variadicSize : 1;
<   return {start, size};
< }
< 
< ::mlir::Operation::result_range MatmulI8I8I32Op::getODSResults(unsigned index) {
<   auto valueRange = getODSResultIndexAndLength(index);
<   return {std::next(getOperation()->result_begin(), valueRange.first),
<            std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
< }
< 
< ::mlir::Operation::result_range MatmulI8I8I32Op::result_tensors() {
<   return getODSResults(0);
< }
< 
< ::mlir::Region &MatmulI8I8I32Op::region() {
<   return (*this)->getRegion(0);
< }
< 
< void MatmulI8I8I32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange inputs, ValueRange outputs, ArrayRef<NamedAttribute> attributes ) {
<           odsState.addOperands(inputs);
<           odsState.addOperands(outputs);
<           odsState.addAttribute(
<             "operand_segment_sizes",
<             odsBuilder.getI32VectorAttr({
<               static_cast<int32_t>(inputs.size()),
<               static_cast<int32_t>(outputs.size())}));
<           odsState.addAttributes(attributes);
<           createAndFillStructuredOpRegion<MatmulI8I8I32Op>(
<             odsBuilder,
<             odsState,
<             TypeRange(inputs),
<             TypeRange(outputs));
<         
< }
< 
< void MatmulI8I8I32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs, ArrayRef<NamedAttribute> attributes ) {
<           odsState.addOperands(inputs);
<           odsState.addOperands(outputs);
<           odsState.addTypes(resultTensorTypes);
<           odsState.addAttribute(
<             "operand_segment_sizes",
<             odsBuilder.getI32VectorAttr({
<               static_cast<int32_t>(inputs.size()),
<               static_cast<int32_t>(outputs.size())}));
<           odsState.addAttributes(attributes);
<           createAndFillStructuredOpRegion<MatmulI8I8I32Op>(
<             odsBuilder,
<             odsState,
<             TypeRange(inputs),
<             TypeRange(outputs));
<         
< }
< 
< void MatmulI8I8I32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes ) {
<           odsState.addOperands(operands);
<           odsState.addAttributes(attributes);
<           odsState.addTypes(resultTensorTypes);
<           (void)odsState.addRegion();
<         
< }
< 
< ::mlir::ParseResult MatmulI8I8I32Op::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
<   return ::parseNamedStructuredOp<MatmulI8I8I32Op>(parser, result);
< }
< 
< void MatmulI8I8I32Op::print(::mlir::OpAsmPrinter &p) {
<   return ::printNamedStructuredOp(p, *this);
< }
< 
< ::mlir::LogicalResult MatmulI8I8I32Op::verify() {
<   if (::mlir::failed(MatmulI8I8I32OpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
<   {
<     unsigned index = 0; (void)index;
<     auto valueGroup0 = getODSOperands(0);
<     for (::mlir::Value v : valueGroup0) {
<       if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps1(getOperation(), v.getType(), "operand", index)))
<         return ::mlir::failure();
<       ++index;
<     }
<     auto valueGroup1 = getODSOperands(1);
<     for (::mlir::Value v : valueGroup1) {
<       if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps1(getOperation(), v.getType(), "operand", index)))
<         return ::mlir::failure();
<       ++index;
<     }
<   }
<   {
<     unsigned index = 0; (void)index;
<     auto valueGroup0 = getODSResults(0);
<     for (::mlir::Value v : valueGroup0) {
<       if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps2(getOperation(), v.getType(), "result", index)))
<         return ::mlir::failure();
<       ++index;
<     }
<   }
< {
<     unsigned index = 0; (void)index;
<     for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
<       (void)region;
<       if (!((true))) {
<         return emitOpError("region #") << index << " ('region') failed to verify constraint: any region";
<       }
<       ++index;
<     }
<   }
<   return ::mlir::success();
< }
< 
< 
< 
< 
< 
< } // namespace linalg
< } // namespace mlir
< DEFINE_EXPLICIT_TYPE_ID(::mlir::linalg::MatmulI8I8I32Op)
diff --color /zyin/IR-release/LinalgStructuredOps.h.inc /zyin/IR-patch/LinalgStructuredOps.h.inc
113,117d112
< class MatmulI8I8I32Op;
< } // namespace linalg
< } // namespace mlir
< namespace mlir {
< namespace linalg {
2744,2851d2738
< 
< namespace mlir {
< namespace linalg {
< 
< //===----------------------------------------------------------------------===//
< // ::mlir::linalg::MatmulI8I8I32Op declarations
< //===----------------------------------------------------------------------===//
< 
< class MatmulI8I8I32OpAdaptor {
< public:
<   MatmulI8I8I32OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions = {});
<   MatmulI8I8I32OpAdaptor(MatmulI8I8I32Op&op);
<   ::mlir::ValueRange getOperands();
<   std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
<   ::mlir::ValueRange getODSOperands(unsigned index);
<   ::mlir::ValueRange inputs();
<   ::mlir::ValueRange outputs();
<   ::mlir::DictionaryAttr getAttributes();
<   ::mlir::RegionRange getRegions();
<   ::mlir::Region &region();
<   ::mlir::LogicalResult verify(::mlir::Location loc);
< 
< private:
<   ::mlir::ValueRange odsOperands;
<   ::mlir::DictionaryAttr odsAttrs;
<   ::mlir::RegionRange odsRegions;
< };
< class MatmulI8I8I32Op : public ::mlir::Op<MatmulI8I8I32Op, ::mlir::OpTrait::OneRegion, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessor, ::mlir::OpTrait::VariadicOperands, ::mlir::linalg::LinalgOp::Trait, ::mlir::ReifyRankedShapedTypeOpInterface::Trait, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::SingleBlockImplicitTerminator<YieldOp>::Impl, ::mlir::linalg::ContractionOpInterface::Trait> {
< public:
<   using Op::Op;
<   using Op::print;
<   using Adaptor = MatmulI8I8I32OpAdaptor;
<   static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
<     static ::llvm::StringRef attrNames[] = {::llvm::StringRef("operand_segment_sizes")};
<   return ::llvm::makeArrayRef(attrNames);
<   }
<   ::mlir::Identifier operand_segment_sizesAttrName() {
<     return getAttributeNameForIndex(0);
<   }
<   static ::mlir::Identifier operand_segment_sizesAttrName(::mlir::OperationName name) {
<     return getAttributeNameForIndex(name, 0);
<   }
<   static constexpr ::llvm::StringLiteral getOperationName() {
<     return ::llvm::StringLiteral("linalg.matmul_i8_i8_i32");
<   }
<   std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
<   ::mlir::Operation::operand_range getODSOperands(unsigned index);
<   ::mlir::Operation::operand_range inputs();
<   ::mlir::Operation::operand_range outputs();
<   ::mlir::MutableOperandRange inputsMutable();
<   ::mlir::MutableOperandRange outputsMutable();
<   std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
<   ::mlir::Operation::result_range getODSResults(unsigned index);
<   ::mlir::Operation::result_range result_tensors();
<   ::mlir::Region &region();
<   static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange inputs, ValueRange outputs, ArrayRef<NamedAttribute> attributes = {});
<   static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs, ArrayRef<NamedAttribute> attributes = {});
<   static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes = {});
<   static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
<   void print(::mlir::OpAsmPrinter &p);
<   ::mlir::LogicalResult verify();
<   ::mlir::LogicalResult fold(::llvm::ArrayRef<::mlir::Attribute> operands, ::llvm::SmallVectorImpl<::mlir::OpFoldResult> &results);
<   void getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
< 
<     // Return whether the op accesses the iteration indices.
<     bool hasIndexSemantics() {
<       Operation *op = this->getOperation();
<       if(op->getNumRegions() == 0 || op->getRegion(0).empty())
<         return false;
<       return !op->getRegion(0).front().getOps<IndexOp>().empty();
<     }
< 
<     LogicalResult reifyResultShapes(OpBuilder &b,
<         ReifiedRankedShapedTypeDims &reifiedReturnShapes) {
<       return cast<LinalgOp>(getOperation()).reifyResultShapes(b,
<           reifiedReturnShapes);
<     }
<   
<         // Auto-generated.
<         ArrayAttr iterator_types();
<         ArrayAttr indexing_maps();
<         static void regionBuilder(ImplicitLocOpBuilder &b, Block &block);
<         static std::function<void(ImplicitLocOpBuilder &b, Block &)>
<         getRegionBuilder() {
<           return regionBuilder;
<         }
< 
<         // Generic methods.
<         static unsigned getNumRegionArgs() { return 3; }
<         std::string getLibraryCallName() {
<           return generateLibraryCallName(getOperation());
<         }
< 
<         
<       
< 
< private:
<   ::mlir::Identifier getAttributeNameForIndex(unsigned index) {
<     return getAttributeNameForIndex((*this)->getName(), index);
<   }
<   static ::mlir::Identifier getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
<   assert(index < 1 && "invalid attribute index");
<   return name.getAbstractOperation()->getAttributeNames()[index];
<   }
< };
< } // namespace linalg
< } // namespace mlir
< DECLARE_EXPLICIT_TYPE_ID(::mlir::linalg::MatmulI8I8I32Op)
diff --color /zyin/IR-release/Makefile /zyin/IR-patch/Makefile
77a78,89
> # Special rule for the target install/strip
> install/strip: preinstall
> 	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --cyan "Installing the project stripped..."
> 	/usr/bin/cmake -DCMAKE_INSTALL_DO_STRIP=1 -P cmake_install.cmake
> .PHONY : install/strip
> 
> # Special rule for the target install/strip
> install/strip/fast: preinstall/fast
> 	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --cyan "Installing the project stripped..."
> 	/usr/bin/cmake -DCMAKE_INSTALL_DO_STRIP=1 -P cmake_install.cmake
> .PHONY : install/strip/fast
> 
92c104
< 	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --cyan "Available install components are: \"ExampleIRTransforms\" \"FileCheck\" \"LLVMAMDGPUAsmParser\" \"LLVMAMDGPUCodeGen\" \"LLVMAMDGPUDesc\" \"LLVMAMDGPUDisassembler\" \"LLVMAMDGPUInfo\" \"LLVMAMDGPUTargetMCA\" \"LLVMAMDGPUUtils\" \"LLVMAggressiveInstCombine\" \"LLVMAnalysis\" \"LLVMAsmParser\" \"LLVMAsmPrinter\" \"LLVMBinaryFormat\" \"LLVMBitReader\" \"LLVMBitWriter\" \"LLVMBitstreamReader\" \"LLVMCFGuard\" \"LLVMCFIVerify\" \"LLVMCodeGen\" \"LLVMCore\" \"LLVMCoroutines\" \"LLVMCoverage\" \"LLVMDWARFLinker\" \"LLVMDWP\" \"LLVMDebugInfoCodeView\" \"LLVMDebugInfoDWARF\" \"LLVMDebugInfoGSYM\" \"LLVMDebugInfoMSF\" \"LLVMDebugInfoPDB\" \"LLVMDemangle\" \"LLVMDiff\" \"LLVMDlltoolDriver\" \"LLVMExecutionEngine\" \"LLVMExegesis\" \"LLVMExegesisX86\" \"LLVMExtensions\" \"LLVMFileCheck\" \"LLVMFrontendOpenACC\" \"LLVMFrontendOpenMP\" \"LLVMFuzzMutate\" \"LLVMGlobalISel\" \"LLVMIRReader\" \"LLVMInstCombine\" \"LLVMInstrumentation\" \"LLVMInterfaceStub\" \"LLVMInterpreter\" \"LLVMJITLink\" \"LLVMLTO\" \"LLVMLibDriver\" \"LLVMLineEditor\" \"LLVMLinker\" \"LLVMMC\" \"LLVMMCA\" \"LLVMMCDisassembler\" \"LLVMMCJIT\" \"LLVMMCParser\" \"LLVMMIRParser\" \"LLVMObjCARCOpts\" \"LLVMObject\" \"LLVMObjectYAML\" \"LLVMOption\" \"LLVMOrcJIT\" \"LLVMOrcShared\" \"LLVMOrcTargetProcess\" \"LLVMPasses\" \"LLVMProfileData\" \"LLVMROCmBackendUtils\" \"LLVMRemarks\" \"LLVMRuntimeDyld\" \"LLVMScalarOpts\" \"LLVMSelectionDAG\" \"LLVMSupport\" \"LLVMSymbolize\" \"LLVMTableGen\" \"LLVMTableGenGlobalISel\" \"LLVMTarget\" \"LLVMTextAPI\" \"LLVMTransformUtils\" \"LLVMVectorize\" \"LLVMWindowsManifest\" \"LLVMX86AsmParser\" \"LLVMX86CodeGen\" \"LLVMX86Desc\" \"LLVMX86Disassembler\" \"LLVMX86Info\" \"LLVMXRay\" \"LLVMipo\" \"LTO\" \"MIOpenOptMain\" \"MLIRAMX\" \"MLIRAMXToLLVMIRTranslation\" \"MLIRAMXTransforms\" \"MLIRAffine\" \"MLIRAffineToStandard\" \"MLIRAffineTransforms\" \"MLIRAffineTransformsTestPasses\" \"MLIRAffineUtils\" \"MLIRAnalysis\" \"MLIRArmNeon\" \"MLIRArmNeon2dToIntr\" \"MLIRArmNeonToLLVMIRTranslation\" \"MLIRArmSVE\" \"MLIRArmSVEToLLVMIRTranslation\" \"MLIRArmSVETransforms\" \"MLIRAsync\" \"MLIRAsyncToLLVM\" \"MLIRAsyncTransforms\" \"MLIRCAPIAsync\" \"MLIRCAPIConversion\" \"MLIRCAPIDebug\" \"MLIRCAPIGPU\" \"MLIRCAPIIR\" \"MLIRCAPILLVM\" \"MLIRCAPILinalg\" \"MLIRCAPIMIGraphX\" \"MLIRCAPIRegistration\" \"MLIRCAPISCF\" \"MLIRCAPIShape\" \"MLIRCAPISparseTensor\" \"MLIRCAPIStandard\" \"MLIRCAPITensor\" \"MLIRCAPITransforms\" \"MLIRCEXECUTIONENGINE\" \"MLIRCallInterfaces\" \"MLIRCastInterfaces\" \"MLIRComplex\" \"MLIRComplexToLLVM\" \"MLIRComplexToStandard\" \"MLIRControlFlowInterfaces\" \"MLIRCopyOpInterface\" \"MLIRDLTI\" \"MLIRDLTITestPasses\" \"MLIRDataLayoutInterfaces\" \"MLIRDerivedAttributeOpInterface\" \"MLIRDialect\" \"MLIRDialectUtils\" \"MLIREmitC\" \"MLIRExecutionEngine\" \"MLIRGPUOps\" \"MLIRGPUTestPasses\" \"MLIRGPUToGPURuntimeTransforms\" \"MLIRGPUToNVVMTransforms\" \"MLIRGPUToROCDLTransforms\" \"MLIRGPUToSPIRV\" \"MLIRGPUToVulkanTransforms\" \"MLIRGPUTransforms\" \"MLIRIR\" \"MLIRInferTypeOpInterface\" \"MLIRJitRunner\" \"MLIRLLVMCommonConversion\" \"MLIRLLVMIR\" \"MLIRLLVMIRTransforms\" \"MLIRLLVMToLLVMIRTranslation\" \"MLIRLinalg\" \"MLIRLinalgAnalysis\" \"MLIRLinalgTestPasses\" \"MLIRLinalgToLLVM\" \"MLIRLinalgToSPIRV\" \"MLIRLinalgToStandard\" \"MLIRLinalgTransforms\" \"MLIRLinalgUtils\" \"MLIRLoopAnalysis\" \"MLIRLoopLikeInterface\" \"MLIRLspServerLib\" \"MLIRMIGraphX\" \"MLIRMIGraphXToTosa\" \"MLIRMIOpenConv2dGenerator\" \"MLIRMIOpenOps\" \"MLIRMIOpenPipeline\" \"MLIRMIOpenToGPU\" \"MLIRMIOpenTransforms\" \"MLIRMIOpenTuning\" \"MLIRMath\" \"MLIRMathTestPasses\" \"MLIRMathToLLVM\" \"MLIRMathToLibm\" \"MLIRMathToSPIRV\" \"MLIRMathTransforms\" \"MLIRMemRef\" \"MLIRMemRefToLLVM\" \"MLIRMemRefToSPIRV\" \"MLIRMemRefTransforms\" \"MLIRMemRefUtils\" \"MLIRMlirOptMain\" \"MLIRNVVMIR\" \"MLIRNVVMToLLVMIRTranslation\" \"MLIROpenACC\" \"MLIROpenACCToLLVM\" \"MLIROpenACCToLLVMIRTranslation\" \"MLIROpenACCToSCF\" \"MLIROpenMP\" \"MLIROpenMPToLLVM\" \"MLIROpenMPToLLVMIRTranslation\" \"MLIROptLib\" \"MLIRPDL\" \"MLIRPDLInterp\" \"MLIRPDLToPDLInterp\" \"MLIRParser\" \"MLIRPass\" \"MLIRPresburger\" \"MLIRQuant\" \"MLIRROCDLIR\" \"MLIRROCDLToLLVMIRTranslation\" \"MLIRReconcileUnrealizedCasts\" \"MLIRReduce\" \"MLIRReduceLib\" \"MLIRRewrite\" \"MLIRSCF\" \"MLIRSCFTestPasses\" \"MLIRSCFToGPU\" \"MLIRSCFToOpenMP\" \"MLIRSCFToSPIRV\" \"MLIRSCFToStandard\" \"MLIRSCFTransforms\" \"MLIRSPIRV\" \"MLIRSPIRVBinaryUtils\" \"MLIRSPIRVConversion\" \"MLIRSPIRVDeserialization\" \"MLIRSPIRVModuleCombiner\" \"MLIRSPIRVSerialization\" \"MLIRSPIRVTestPasses\" \"MLIRSPIRVToLLVM\" \"MLIRSPIRVTransforms\" \"MLIRSPIRVTranslateRegistration\" \"MLIRSPIRVUtils\" \"MLIRShape\" \"MLIRShapeOpsTransforms\" \"MLIRShapeTestPasses\" \"MLIRShapeToStandard\" \"MLIRSideEffectInterfaces\" \"MLIRSparseTensor\" \"MLIRSparseTensorTransforms\" \"MLIRSparseTensorUtils\" \"MLIRStandard\" \"MLIRStandardOpsTestPasses\" \"MLIRStandardOpsTransforms\" \"MLIRStandardToLLVM\" \"MLIRStandardToSPIRV\" \"MLIRSupport\" \"MLIRSupportIndentedOstream\" \"MLIRTableGen\" \"MLIRTargetCpp\" \"MLIRTargetLLVMIRExport\" \"MLIRTargetLLVMIRImport\" \"MLIRTensor\" \"MLIRTensorTransforms\" \"MLIRTestAnalysis\" \"MLIRTestDialect\" \"MLIRTestIR\" \"MLIRTestPass\" \"MLIRTestReducer\" \"MLIRTestRewrite\" \"MLIRTestStandardToLLVM\" \"MLIRTestTransforms\" \"MLIRTilingInterface\" \"MLIRToLLVMIRTranslationRegistration\" \"MLIRTosa\" \"MLIRTosaTestPasses\" \"MLIRTosaToLinalg\" \"MLIRTosaToMIOpen\" \"MLIRTosaToSCF\" \"MLIRTosaToStandard\" \"MLIRTosaTransforms\" \"MLIRTransformUtils\" \"MLIRTransforms\" \"MLIRTranslation\" \"MLIRVector\" \"MLIRVectorInterfaces\" \"MLIRVectorTestPasses\" \"MLIRVectorToGPU\" \"MLIRVectorToLLVM\" \"MLIRVectorToROCDL\" \"MLIRVectorToSCF\" \"MLIRVectorToSPIRV\" \"MLIRViewLikeInterface\" \"MLIRX86Vector\" \"MLIRX86VectorToLLVMIRTranslation\" \"MLIRX86VectorTransforms\" \"Remarks\" \"Unspecified\" \"bugpoint\" \"cmake-exports\" \"count\" \"dsymutil\" \"libMLIRMIOpen\" \"llc\" \"lld\" \"lld-cmake-exports\" \"lldCOFF\" \"lldCommon\" \"lldCore\" \"lldDriver\" \"lldELF\" \"lldMachO\" \"lldMachOOld\" \"lldMinGW\" \"lldReaderWriter\" \"lldWasm\" \"lldYAML\" \"lli\" \"lli-child-target\" \"llvm-PerfectShuffle\" \"llvm-addr2line\" \"llvm-ar\" \"llvm-as\" \"llvm-bcanalyzer\" \"llvm-bitcode-strip\" \"llvm-c-test\" \"llvm-cat\" \"llvm-cfi-verify\" \"llvm-config\" \"llvm-cov\" \"llvm-cvtres\" \"llvm-cxxdump\" \"llvm-cxxfilt\" \"llvm-cxxmap\" \"llvm-diff\" \"llvm-dis\" \"llvm-dlltool\" \"llvm-dwarfdump\" \"llvm-dwp\" \"llvm-exegesis\" \"llvm-extract\" \"llvm-gsymutil\" \"llvm-headers\" \"llvm-ifs\" \"llvm-install-name-tool\" \"llvm-jitlink\" \"llvm-jitlink-executor\" \"llvm-lib\" \"llvm-libtool-darwin\" \"llvm-link\" \"llvm-lipo\" \"llvm-lto\" \"llvm-lto2\" \"llvm-mc\" \"llvm-mca\" \"llvm-ml\" \"llvm-modextract\" \"llvm-mt\" \"llvm-nm\" \"llvm-objcopy\" \"llvm-objdump\" \"llvm-opt-report\" \"llvm-otool\" \"llvm-pdbutil\" \"llvm-profdata\" \"llvm-profgen\" \"llvm-ranlib\" \"llvm-rc\" \"llvm-readelf\" \"llvm-readobj\" \"llvm-reduce\" \"llvm-rtdyld\" \"llvm-sim\" \"llvm-size\" \"llvm-split\" \"llvm-stress\" \"llvm-strings\" \"llvm-strip\" \"llvm-symbolizer\" \"llvm-tapi-diff\" \"llvm-tblgen\" \"llvm-undname\" \"llvm-windres\" \"llvm-xray\" \"miopen-opt\" \"miopen-translate\" \"mlir-cmake-exports\" \"mlir-cpu-runner\" \"mlir-headers\" \"mlir-linalg-ods-gen\" \"mlir-linalg-ods-yaml-gen\" \"mlir-lsp-server\" \"mlir-opt\" \"mlir-reduce\" \"mlir-rocm-runner\" \"mlir-tblgen\" \"mlir-translate\" \"mlir_async_runtime\" \"mlir_c_runner_utils\" \"mlir_rocm_runtime\" \"mlir_runner_utils\" \"not\" \"obj2yaml\" \"opt\" \"opt-viewer\" \"rocm-runtime-wrappers\" \"sancov\" \"sanstats\" \"split-file\" \"verify-uselistorder\" \"yaml-bench\" \"yaml2obj\""
---
> 	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --cyan "Available install components are: \"ExampleIRTransforms\" \"FileCheck\" \"LLVMAMDGPUAsmParser\" \"LLVMAMDGPUCodeGen\" \"LLVMAMDGPUDesc\" \"LLVMAMDGPUDisassembler\" \"LLVMAMDGPUInfo\" \"LLVMAMDGPUTargetMCA\" \"LLVMAMDGPUUtils\" \"LLVMAggressiveInstCombine\" \"LLVMAnalysis\" \"LLVMAsmParser\" \"LLVMAsmPrinter\" \"LLVMBinaryFormat\" \"LLVMBitReader\" \"LLVMBitWriter\" \"LLVMBitstreamReader\" \"LLVMCFGuard\" \"LLVMCFIVerify\" \"LLVMCodeGen\" \"LLVMCore\" \"LLVMCoroutines\" \"LLVMCoverage\" \"LLVMDWARFLinker\" \"LLVMDWP\" \"LLVMDebugInfoCodeView\" \"LLVMDebugInfoDWARF\" \"LLVMDebugInfoGSYM\" \"LLVMDebugInfoMSF\" \"LLVMDebugInfoPDB\" \"LLVMDemangle\" \"LLVMDiff\" \"LLVMDlltoolDriver\" \"LLVMExecutionEngine\" \"LLVMExegesis\" \"LLVMExegesisX86\" \"LLVMExtensions\" \"LLVMFileCheck\" \"LLVMFrontendOpenACC\" \"LLVMFrontendOpenMP\" \"LLVMFuzzMutate\" \"LLVMGlobalISel\" \"LLVMIRReader\" \"LLVMInstCombine\" \"LLVMInstrumentation\" \"LLVMInterfaceStub\" \"LLVMInterpreter\" \"LLVMJITLink\" \"LLVMLTO\" \"LLVMLibDriver\" \"LLVMLineEditor\" \"LLVMLinker\" \"LLVMMC\" \"LLVMMCA\" \"LLVMMCDisassembler\" \"LLVMMCJIT\" \"LLVMMCParser\" \"LLVMMIRParser\" \"LLVMObjCARCOpts\" \"LLVMObject\" \"LLVMObjectYAML\" \"LLVMOption\" \"LLVMOrcJIT\" \"LLVMOrcShared\" \"LLVMOrcTargetProcess\" \"LLVMPasses\" \"LLVMProfileData\" \"LLVMROCmBackendUtils\" \"LLVMRemarks\" \"LLVMRuntimeDyld\" \"LLVMScalarOpts\" \"LLVMSelectionDAG\" \"LLVMSupport\" \"LLVMSymbolize\" \"LLVMTableGen\" \"LLVMTableGenGlobalISel\" \"LLVMTarget\" \"LLVMTextAPI\" \"LLVMTransformUtils\" \"LLVMVectorize\" \"LLVMWindowsManifest\" \"LLVMX86AsmParser\" \"LLVMX86CodeGen\" \"LLVMX86Desc\" \"LLVMX86Disassembler\" \"LLVMX86Info\" \"LLVMXRay\" \"LLVMipo\" \"LTO\" \"MIOpenOptMain\" \"MLIRAMX\" \"MLIRAMXToLLVMIRTranslation\" \"MLIRAMXTransforms\" \"MLIRAffine\" \"MLIRAffineToStandard\" \"MLIRAffineTransforms\" \"MLIRAffineTransformsTestPasses\" \"MLIRAffineUtils\" \"MLIRAnalysis\" \"MLIRArmNeon\" \"MLIRArmNeon2dToIntr\" \"MLIRArmNeonToLLVMIRTranslation\" \"MLIRArmSVE\" \"MLIRArmSVEToLLVMIRTranslation\" \"MLIRArmSVETransforms\" \"MLIRAsync\" \"MLIRAsyncToLLVM\" \"MLIRAsyncTransforms\" \"MLIRCAPIAsync\" \"MLIRCAPIConversion\" \"MLIRCAPIDebug\" \"MLIRCAPIGPU\" \"MLIRCAPIIR\" \"MLIRCAPILLVM\" \"MLIRCAPILinalg\" \"MLIRCAPIMIGraphX\" \"MLIRCAPIRegistration\" \"MLIRCAPISCF\" \"MLIRCAPIShape\" \"MLIRCAPISparseTensor\" \"MLIRCAPIStandard\" \"MLIRCAPITensor\" \"MLIRCAPITransforms\" \"MLIRCEXECUTIONENGINE\" \"MLIRCallInterfaces\" \"MLIRCastInterfaces\" \"MLIRComplex\" \"MLIRComplexToLLVM\" \"MLIRComplexToStandard\" \"MLIRControlFlowInterfaces\" \"MLIRCopyOpInterface\" \"MLIRDLTI\" \"MLIRDLTITestPasses\" \"MLIRDataLayoutInterfaces\" \"MLIRDerivedAttributeOpInterface\" \"MLIRDialect\" \"MLIRDialectUtils\" \"MLIREmitC\" \"MLIRExecutionEngine\" \"MLIRGPUOps\" \"MLIRGPUTestPasses\" \"MLIRGPUToGPURuntimeTransforms\" \"MLIRGPUToNVVMTransforms\" \"MLIRGPUToROCDLTransforms\" \"MLIRGPUToSPIRV\" \"MLIRGPUToVulkanTransforms\" \"MLIRGPUTransforms\" \"MLIRIR\" \"MLIRInferTypeOpInterface\" \"MLIRJitRunner\" \"MLIRLLVMCommonConversion\" \"MLIRLLVMIR\" \"MLIRLLVMIRTransforms\" \"MLIRLLVMToLLVMIRTranslation\" \"MLIRLinalg\" \"MLIRLinalgAnalysis\" \"MLIRLinalgTestPasses\" \"MLIRLinalgToLLVM\" \"MLIRLinalgToSPIRV\" \"MLIRLinalgToStandard\" \"MLIRLinalgTransforms\" \"MLIRLinalgUtils\" \"MLIRLoopAnalysis\" \"MLIRLoopLikeInterface\" \"MLIRLspServerLib\" \"MLIRMIGraphX\" \"MLIRMIGraphXToTosa\" \"MLIRMIOpenConv2dGenerator\" \"MLIRMIOpenOps\" \"MLIRMIOpenPipeline\" \"MLIRMIOpenToGPU\" \"MLIRMIOpenTransforms\" \"MLIRMIOpenTuning\" \"MLIRMath\" \"MLIRMathTestPasses\" \"MLIRMathToLLVM\" \"MLIRMathToLibm\" \"MLIRMathToSPIRV\" \"MLIRMathTransforms\" \"MLIRMemRef\" \"MLIRMemRefToLLVM\" \"MLIRMemRefToSPIRV\" \"MLIRMemRefTransforms\" \"MLIRMemRefUtils\" \"MLIRMlirOptMain\" \"MLIRNVVMIR\" \"MLIRNVVMToLLVMIRTranslation\" \"MLIROpenACC\" \"MLIROpenACCToLLVM\" \"MLIROpenACCToLLVMIRTranslation\" \"MLIROpenACCToSCF\" \"MLIROpenMP\" \"MLIROpenMPToLLVM\" \"MLIROpenMPToLLVMIRTranslation\" \"MLIROptLib\" \"MLIRPDL\" \"MLIRPDLInterp\" \"MLIRPDLToPDLInterp\" \"MLIRParser\" \"MLIRPass\" \"MLIRPresburger\" \"MLIRQuant\" \"MLIRROCDLIR\" \"MLIRROCDLToLLVMIRTranslation\" \"MLIRReconcileUnrealizedCasts\" \"MLIRReduce\" \"MLIRReduceLib\" \"MLIRRewrite\" \"MLIRSCF\" \"MLIRSCFTestPasses\" \"MLIRSCFToGPU\" \"MLIRSCFToOpenMP\" \"MLIRSCFToSPIRV\" \"MLIRSCFToStandard\" \"MLIRSCFTransforms\" \"MLIRSPIRV\" \"MLIRSPIRVBinaryUtils\" \"MLIRSPIRVConversion\" \"MLIRSPIRVDeserialization\" \"MLIRSPIRVModuleCombiner\" \"MLIRSPIRVSerialization\" \"MLIRSPIRVTestPasses\" \"MLIRSPIRVToLLVM\" \"MLIRSPIRVTransforms\" \"MLIRSPIRVTranslateRegistration\" \"MLIRSPIRVUtils\" \"MLIRShape\" \"MLIRShapeOpsTransforms\" \"MLIRShapeTestPasses\" \"MLIRShapeToStandard\" \"MLIRSideEffectInterfaces\" \"MLIRSparseTensor\" \"MLIRSparseTensorTransforms\" \"MLIRSparseTensorUtils\" \"MLIRStandard\" \"MLIRStandardOpsTestPasses\" \"MLIRStandardOpsTransforms\" \"MLIRStandardToLLVM\" \"MLIRStandardToSPIRV\" \"MLIRSupport\" \"MLIRSupportIndentedOstream\" \"MLIRTableGen\" \"MLIRTargetCpp\" \"MLIRTargetLLVMIRExport\" \"MLIRTargetLLVMIRImport\" \"MLIRTensor\" \"MLIRTensorTransforms\" \"MLIRTestAnalysis\" \"MLIRTestDialect\" \"MLIRTestIR\" \"MLIRTestPass\" \"MLIRTestReducer\" \"MLIRTestRewrite\" \"MLIRTestStandardToLLVM\" \"MLIRTestTransforms\" \"MLIRTilingInterface\" \"MLIRToLLVMIRTranslationRegistration\" \"MLIRTosa\" \"MLIRTosaTestPasses\" \"MLIRTosaToLinalg\" \"MLIRTosaToMIOpen\" \"MLIRTosaToSCF\" \"MLIRTosaToStandard\" \"MLIRTosaTransforms\" \"MLIRTransformUtils\" \"MLIRTransforms\" \"MLIRTranslation\" \"MLIRVector\" \"MLIRVectorInterfaces\" \"MLIRVectorTestPasses\" \"MLIRVectorToGPU\" \"MLIRVectorToLLVM\" \"MLIRVectorToROCDL\" \"MLIRVectorToSCF\" \"MLIRVectorToSPIRV\" \"MLIRViewLikeInterface\" \"MLIRX86Vector\" \"MLIRX86VectorToLLVMIRTranslation\" \"MLIRX86VectorTransforms\" \"Remarks\" \"Unspecified\" \"bugpoint\" \"cmake-exports\" \"count\" \"dsymutil\" \"libMLIRMIOpen\" \"llc\" \"lld\" \"lld-cmake-exports\" \"lldCOFF\" \"lldCommon\" \"lldCore\" \"lldDriver\" \"lldELF\" \"lldMachO\" \"lldMachOOld\" \"lldMinGW\" \"lldReaderWriter\" \"lldWasm\" \"lldYAML\" \"lli\" \"lli-child-target\" \"llvm-PerfectShuffle\" \"llvm-addr2line\" \"llvm-ar\" \"llvm-as\" \"llvm-bcanalyzer\" \"llvm-bitcode-strip\" \"llvm-c-test\" \"llvm-cat\" \"llvm-cfi-verify\" \"llvm-config\" \"llvm-cov\" \"llvm-cvtres\" \"llvm-cxxdump\" \"llvm-cxxfilt\" \"llvm-cxxmap\" \"llvm-diff\" \"llvm-dis\" \"llvm-dlltool\" \"llvm-dwarfdump\" \"llvm-dwp\" \"llvm-exegesis\" \"llvm-extract\" \"llvm-gsymutil\" \"llvm-headers\" \"llvm-ifs\" \"llvm-install-name-tool\" \"llvm-jitlink\" \"llvm-jitlink-executor\" \"llvm-lib\" \"llvm-libtool-darwin\" \"llvm-link\" \"llvm-lipo\" \"llvm-lto\" \"llvm-lto2\" \"llvm-mc\" \"llvm-mca\" \"llvm-ml\" \"llvm-modextract\" \"llvm-mt\" \"llvm-nm\" \"llvm-objcopy\" \"llvm-objdump\" \"llvm-opt-report\" \"llvm-otool\" \"llvm-pdbutil\" \"llvm-profdata\" \"llvm-profgen\" \"llvm-ranlib\" \"llvm-rc\" \"llvm-readelf\" \"llvm-readobj\" \"llvm-reduce\" \"llvm-rtdyld\" \"llvm-sim\" \"llvm-size\" \"llvm-split\" \"llvm-stress\" \"llvm-strings\" \"llvm-strip\" \"llvm-symbolizer\" \"llvm-tapi-diff\" \"llvm-tblgen\" \"llvm-undname\" \"llvm-windres\" \"llvm-xray\" \"miopen-opt\" \"miopen-translate\" \"mlir-cmake-exports\" \"mlir-cpu-runner\" \"mlir-headers\" \"mlir-linalg-ods-yaml-gen\" \"mlir-lsp-server\" \"mlir-opt\" \"mlir-reduce\" \"mlir-rocm-runner\" \"mlir-tblgen\" \"mlir-translate\" \"mlir_async_runtime\" \"mlir_c_runner_utils\" \"mlir_rocm_runtime\" \"mlir_runner_utils\" \"not\" \"obj2yaml\" \"opt\" \"opt-viewer\" \"rocm-runtime-wrappers\" \"sancov\" \"sanstats\" \"split-file\" \"verify-uselistorder\" \"yaml-bench\" \"yaml2obj\""
122,133d133
< # Special rule for the target install/strip
< install/strip: preinstall
< 	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --cyan "Installing the project stripped..."
< 	/usr/bin/cmake -DCMAKE_INSTALL_DO_STRIP=1 -P cmake_install.cmake
< .PHONY : install/strip
< 
< # Special rule for the target install/strip
< install/strip/fast: preinstall/fast
< 	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --cyan "Installing the project stripped..."
< 	/usr/bin/cmake -DCMAKE_INSTALL_DO_STRIP=1 -P cmake_install.cmake
< .PHONY : install/strip/fast
< 
201,203c201,203
< external/llvm-project/llvm/tools/mlir/include/mlir/Dialect/Linalg/IR/CMakeFiles/MLIRLinalgInterfacesIncGen.dir/rule:
< 	cd /long_pathname_so_that_rpms_can_package_the_debug_info/data/driver/llvm-project-mlir/build-lib && $(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 external/llvm-project/llvm/tools/mlir/include/mlir/Dialect/Linalg/IR/CMakeFiles/MLIRLinalgInterfacesIncGen.dir/rule
< .PHONY : external/llvm-project/llvm/tools/mlir/include/mlir/Dialect/Linalg/IR/CMakeFiles/MLIRLinalgInterfacesIncGen.dir/rule
---
> external/llvm-project/llvm/tools/mlir/include/mlir/Dialect/Linalg/IR/CMakeFiles/LinalgOdsGen.dir/rule:
> 	cd /long_pathname_so_that_rpms_can_package_the_debug_info/data/driver/llvm-project-mlir/build-lib && $(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 external/llvm-project/llvm/tools/mlir/include/mlir/Dialect/Linalg/IR/CMakeFiles/LinalgOdsGen.dir/rule
> .PHONY : external/llvm-project/llvm/tools/mlir/include/mlir/Dialect/Linalg/IR/CMakeFiles/LinalgOdsGen.dir/rule
206c206
< MLIRLinalgInterfacesIncGen: external/llvm-project/llvm/tools/mlir/include/mlir/Dialect/Linalg/IR/CMakeFiles/MLIRLinalgInterfacesIncGen.dir/rule
---
> LinalgOdsGen: external/llvm-project/llvm/tools/mlir/include/mlir/Dialect/Linalg/IR/CMakeFiles/LinalgOdsGen.dir/rule
208c208
< .PHONY : MLIRLinalgInterfacesIncGen
---
> .PHONY : LinalgOdsGen
211,213c211,213
< MLIRLinalgInterfacesIncGen/fast:
< 	cd /long_pathname_so_that_rpms_can_package_the_debug_info/data/driver/llvm-project-mlir/build-lib && $(MAKE) $(MAKESILENT) -f external/llvm-project/llvm/tools/mlir/include/mlir/Dialect/Linalg/IR/CMakeFiles/MLIRLinalgInterfacesIncGen.dir/build.make external/llvm-project/llvm/tools/mlir/include/mlir/Dialect/Linalg/IR/CMakeFiles/MLIRLinalgInterfacesIncGen.dir/build
< .PHONY : MLIRLinalgInterfacesIncGen/fast
---
> LinalgOdsGen/fast:
> 	cd /long_pathname_so_that_rpms_can_package_the_debug_info/data/driver/llvm-project-mlir/build-lib && $(MAKE) $(MAKESILENT) -f external/llvm-project/llvm/tools/mlir/include/mlir/Dialect/Linalg/IR/CMakeFiles/LinalgOdsGen.dir/build.make external/llvm-project/llvm/tools/mlir/include/mlir/Dialect/Linalg/IR/CMakeFiles/LinalgOdsGen.dir/build
> .PHONY : LinalgOdsGen/fast
231,260d230
< external/llvm-project/llvm/tools/mlir/include/mlir/Dialect/Linalg/IR/CMakeFiles/MLIRLinalgNamedStructuredOpsTcIncGen.dir/rule:
< 	cd /long_pathname_so_that_rpms_can_package_the_debug_info/data/driver/llvm-project-mlir/build-lib && $(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 external/llvm-project/llvm/tools/mlir/include/mlir/Dialect/Linalg/IR/CMakeFiles/MLIRLinalgNamedStructuredOpsTcIncGen.dir/rule
< .PHONY : external/llvm-project/llvm/tools/mlir/include/mlir/Dialect/Linalg/IR/CMakeFiles/MLIRLinalgNamedStructuredOpsTcIncGen.dir/rule
< 
< # Convenience name for target.
< MLIRLinalgNamedStructuredOpsTcIncGen: external/llvm-project/llvm/tools/mlir/include/mlir/Dialect/Linalg/IR/CMakeFiles/MLIRLinalgNamedStructuredOpsTcIncGen.dir/rule
< 
< .PHONY : MLIRLinalgNamedStructuredOpsTcIncGen
< 
< # fast build rule for target.
< MLIRLinalgNamedStructuredOpsTcIncGen/fast:
< 	cd /long_pathname_so_that_rpms_can_package_the_debug_info/data/driver/llvm-project-mlir/build-lib && $(MAKE) $(MAKESILENT) -f external/llvm-project/llvm/tools/mlir/include/mlir/Dialect/Linalg/IR/CMakeFiles/MLIRLinalgNamedStructuredOpsTcIncGen.dir/build.make external/llvm-project/llvm/tools/mlir/include/mlir/Dialect/Linalg/IR/CMakeFiles/MLIRLinalgNamedStructuredOpsTcIncGen.dir/build
< .PHONY : MLIRLinalgNamedStructuredOpsTcIncGen/fast
< 
< # Convenience name for target.
< external/llvm-project/llvm/tools/mlir/include/mlir/Dialect/Linalg/IR/CMakeFiles/LinalgOdsGen.dir/rule:
< 	cd /long_pathname_so_that_rpms_can_package_the_debug_info/data/driver/llvm-project-mlir/build-lib && $(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 external/llvm-project/llvm/tools/mlir/include/mlir/Dialect/Linalg/IR/CMakeFiles/LinalgOdsGen.dir/rule
< .PHONY : external/llvm-project/llvm/tools/mlir/include/mlir/Dialect/Linalg/IR/CMakeFiles/LinalgOdsGen.dir/rule
< 
< # Convenience name for target.
< LinalgOdsGen: external/llvm-project/llvm/tools/mlir/include/mlir/Dialect/Linalg/IR/CMakeFiles/LinalgOdsGen.dir/rule
< 
< .PHONY : LinalgOdsGen
< 
< # fast build rule for target.
< LinalgOdsGen/fast:
< 	cd /long_pathname_so_that_rpms_can_package_the_debug_info/data/driver/llvm-project-mlir/build-lib && $(MAKE) $(MAKESILENT) -f external/llvm-project/llvm/tools/mlir/include/mlir/Dialect/Linalg/IR/CMakeFiles/LinalgOdsGen.dir/build.make external/llvm-project/llvm/tools/mlir/include/mlir/Dialect/Linalg/IR/CMakeFiles/LinalgOdsGen.dir/build
< .PHONY : LinalgOdsGen/fast
< 
< # Convenience name for target.
304a275,289
> # Convenience name for target.
> external/llvm-project/llvm/tools/mlir/include/mlir/Dialect/Linalg/IR/CMakeFiles/MLIRLinalgInterfacesIncGen.dir/rule:
> 	cd /long_pathname_so_that_rpms_can_package_the_debug_info/data/driver/llvm-project-mlir/build-lib && $(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 external/llvm-project/llvm/tools/mlir/include/mlir/Dialect/Linalg/IR/CMakeFiles/MLIRLinalgInterfacesIncGen.dir/rule
> .PHONY : external/llvm-project/llvm/tools/mlir/include/mlir/Dialect/Linalg/IR/CMakeFiles/MLIRLinalgInterfacesIncGen.dir/rule
> 
> # Convenience name for target.
> MLIRLinalgInterfacesIncGen: external/llvm-project/llvm/tools/mlir/include/mlir/Dialect/Linalg/IR/CMakeFiles/MLIRLinalgInterfacesIncGen.dir/rule
> 
> .PHONY : MLIRLinalgInterfacesIncGen
> 
> # fast build rule for target.
> MLIRLinalgInterfacesIncGen/fast:
> 	cd /long_pathname_so_that_rpms_can_package_the_debug_info/data/driver/llvm-project-mlir/build-lib && $(MAKE) $(MAKESILENT) -f external/llvm-project/llvm/tools/mlir/include/mlir/Dialect/Linalg/IR/CMakeFiles/MLIRLinalgInterfacesIncGen.dir/build.make external/llvm-project/llvm/tools/mlir/include/mlir/Dialect/Linalg/IR/CMakeFiles/MLIRLinalgInterfacesIncGen.dir/build
> .PHONY : MLIRLinalgInterfacesIncGen/fast
> 
322d306
< 	@echo "... MLIRLinalgNamedStructuredOpsTcIncGen"
