// RUN: rocmlir-gen -ph -print-results -rand none %s | rocmlir-driver -arch %arch -c  | mlir-cpu-runner -O2 --shared-libs=%linalg_test_lib_dir/libmlir_rocm_runtime%shlibext,%conv_validation_wrapper_library_dir/libconv-validation-wrappers%shlibext,%linalg_test_lib_dir/libmlir_runner_utils%shlibext --entry-point-result=void --mattr=-avx512bf16 | FileCheck %s
// ALLOW_RETRIES: 2

// CHECK: 65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65,      65

#map1 = affine_map<(d0, d1, d2, d3, d4) -> (d0, d1, d2, d3, d4)>
#map2 = affine_map<(d0, d1, d2, d3, d4) -> (0, 0, 0, 0, d4)>
module {{
  func.func @test_fusion(%arg0: memref<1x64x64x64x64x{type}>, %arg1: memref<1x64x1x1x64x{type}>, %arg2: memref<64x{type}>, %arg3: memref<1x64x64x64x64x{type}>) attributes {{kernel, arch = ""}} {{
    %0 = memref.alloc() : memref<1x64x64x64x64x{type}>
    rock.conv2d(%arg1, %arg0, %0) features = none {{arch = "", dilations = [1 : index, 1 : index], filter_layout = ["g", "k", "y", "x", "c"], input_layout = ["gi", "ni", "hi", "wi", "ci"], output_layout = ["go", "no", "ho", "wo", "ko"], padding = [0 : index, 0 : index, 0 : index, 0 : index], strides = [1 : index, 1 : index]}} : memref<1x64x1x1x64x{type}>, memref<1x64x64x64x64x{type}>, memref<1x64x64x64x64x{type}>
    %4 = memref.expand_shape %arg2 [[0, 1, 2, 3, 4]] : memref<64x{type}> into memref<1x1x1x1x64x{type}>
    linalg.generic {{indexing_maps = [#map1, #map2, #map1], iterator_types = ["parallel", "parallel", "parallel", "parallel", "parallel"]}} ins(%0, %4 : memref<1x64x64x64x64x{type}>, memref<1x1x1x1x64x{type}>) outs(%arg3 : memref<1x64x64x64x64x{type}>) {{
    ^bb0(%arg4: {type}, %arg5: {type}, %arg6: {type}):
      %8 = arith.addf %arg4, %arg5 : {type}
      linalg.yield %8 : {type}
    }}
    return
  }}
}}
