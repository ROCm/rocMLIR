// Check whether any errors are occured

// RUN: rocmlir-opt -rock-gridwise-gemm-to-blockwise -rock-pipeline -verify-diagnostics %s
func.func @rock_conv_bwd_data_gkc01_ngc01_ngk01_0(%arg0: memref<147456xf16>, %arg1: memref<6422528xf16>, %arg2: memref<6422528xf16>) attributes {block_size = 256 : i32, grid_size = 196 : i32, kernel = 0 : i32, mhal.arch = "amdgcn-amd-amdhsa:gfx942:sramecc-:xnack--", reverse_grid} {
  %0 = rock.transform %arg0 by <affine_map<(d0, d1, d2, d3, d4) -> ((((d0 * 128 + d1) * 128 + d2) * 3 + d3) * 3 + d4)> by [<Unmerge{1, 128, 128, 3, 3} ["g", "k", "c", "0", "1"] at [0, 1, 2, 3, 4] -> ["raw"] at [0]>] bounds = [1, 128, 128, 3, 3] -> [147456]> : memref<147456xf16> to memref<1x128x128x3x3xf16>
  %1 = rock.transform %arg1 by <affine_map<(d0, d1, d2, d3, d4) -> ((((d0 + d1) * 128 + d2) * 28 + d3) * 28 + d4)> by [<Unmerge{64, 1, 128, 28, 28} ["ni", "gi", "ci", "0i", "1i"] at [0, 1, 2, 3, 4] -> ["raw"] at [0]>] bounds = [64, 1, 128, 28, 28] -> [6422528]> : memref<6422528xf16> to memref<64x1x128x28x28xf16>
  %2 = rock.transform %arg2 by <affine_map<(d0, d1, d2, d3, d4) -> ((((d0 + d1) * 128 + d2) * 28 + d3) * 28 + d4)> by [<Unmerge{64, 1, 128, 28, 28} ["no", "go", "ko", "0o", "1o"] at [0, 1, 2, 3, 4] -> ["raw"] at [0]>] bounds = [64, 1, 128, 28, 28] -> [6422528]> : memref<6422528xf16> to memref<64x1x128x28x28xf16>
  %3 = rock.transform %0 by <affine_map<(d0, d1, d2, d3, d4, d5, d6) -> (d0, d1, d2, d3 + d4, d5 + d6)> by [<PassThrough ["g", "k", "c"] at [0, 1, 2] -> ["g", "k", "c"] at [0, 1, 2]>, <Embed{1, 1} ["0dot", "0tilda"] at [3, 4] -> ["0"] at [3]>, <Embed{1, 1} ["1dot", "1tilda"] at [5, 6] -> ["1"] at [4]>] bounds = [1, 128, 128, 3, 1, 3, 1] -> [1, 128, 128, 3, 3]> : memref<1x128x128x3x3xf16> to memref<1x128x128x3x1x3x1xf16>
  %4 = rock.transform %3 by <affine_map<(d0, d1, d2, d3, d4, d5, d6) -> (d0, d1, d2, d3, d4, d5, d6)> by [<PassThrough ["g", "k", "c"] at [0, 1, 2] -> ["g", "k", "c"] at [0, 1, 2]>, <Slice{0, 3, 0, 3} ["0dotslice", "1dotslice"] at [3, 5] -> ["0dot", "1dot"] at [3, 5]>, <Slice{0, 1, 0, 1} ["0tildaslice", "1tildaslice"] at [4, 6] -> ["0tilda", "1tilda"] at [4, 6]>] bounds = [1, 128, 128, 3, 1, 3, 1] -> [1, 128, 128, 3, 1, 3, 1]> : memref<1x128x128x3x1x3x1xf16> to memref<1x128x128x3x1x3x1xf16>
  %5 = rock.transform %4 by <affine_map<(d0, d1, d2) -> (d0, d1 floordiv 9, d2, (d1 mod 9) floordiv 3, 0, d1 mod 3, 0)> by [<PassThrough ["gemmG"] at [0] -> ["g"] at [0]>, <Merge{128, 3, 3} ["gemmK"] at [1] -> ["k", "0dotslice", "1dotslice"] at [1, 3, 5]>, <Merge{128, 1, 1} ["gemmM"] at [2] -> ["c", "0tildaslice", "1tildaslice"] at [2, 4, 6]>] bounds = [1, 1152, 128] -> [1, 128, 128, 3, 1, 3, 1]> : memref<1x128x128x3x1x3x1xf16> to memref<1x1152x128xf16>
  %6 = rock.transform %1 by <affine_map<(d0, d1, d2, d3, d4) -> (d0, d1, d2, d3 - 1, d4 - 1)> by [<PassThrough ["gi", "ni", "ci"] at [1, 0, 2] -> ["gi", "ni", "ci"] at [1, 0, 2]>, <Pad{1, 1, 1, 1} ["0ipad", "1ipad"] at [3, 4] -> ["0i", "1i"] at [3, 4]>] bounds = [64, 1, 128, 30, 30] -> [64, 1, 128, 28, 28]> : memref<64x1x128x28x28xf16> to memref<64x1x128x30x30xf16>
  %7 = rock.transform %6 by <affine_map<(d0, d1, d2, d3, d4, d5, d6) -> (d0, d1, d2, d3 + d4, d5 + d6)> by [<PassThrough ["gi", "ni", "ci"] at [1, 0, 2] -> ["gi", "ni", "ci"] at [1, 0, 2]>, <Embed{1, 1} ["0ftilda", "0itilda"] at [3, 4] -> ["0ipad"] at [3]>, <Embed{1, 1} ["1ftilda", "1itilda"] at [5, 6] -> ["1ipad"] at [4]>] bounds = [64, 1, 128, 1, 30, 1, 30] -> [64, 1, 128, 30, 30]> : memref<64x1x128x30x30xf16> to memref<64x1x128x1x30x1x30xf16>
  %8 = rock.transform %7 by <affine_map<(d0, d1, d2, d3, d4, d5, d6) -> (d0, d1, d2, d3, d4 + 1, d5, d6 + 1)> by [<PassThrough ["gi", "ni", "ci"] at [1, 0, 2] -> ["gi", "ni", "ci"] at [1, 0, 2]>, <Slice{0, 1, 0, 1} ["0slice", "1slice"] at [3, 5] -> ["0ftilda", "1ftilda"] at [3, 5]>, <Slice{1, 29, 1, 29} ["0islice", "1islice"] at [4, 6] -> ["0itilda", "1itilda"] at [4, 6]>] bounds = [64, 1, 128, 1, 28, 1, 28] -> [64, 1, 128, 1, 30, 1, 30]> : memref<64x1x128x1x30x1x30xf16> to memref<64x1x128x1x28x1x28xf16>
  %9 = rock.transform %8 by <affine_map<(d0, d1, d2) -> (d2 floordiv 784, d0, d1, 0, (d2 mod 784) floordiv 28, 0, d2 mod 28)> by [<PassThrough ["gemmG"] at [0] -> ["gi"] at [1]>, <Merge{128, 1, 1} ["gemmM"] at [1] -> ["ci", "0slice", "1slice"] at [2, 3, 5]>, <Merge{64, 28, 28} ["gemmN"] at [2] -> ["ni", "0islice", "1islice"] at [0, 4, 6]>] bounds = [1, 128, 50176] -> [64, 1, 128, 1, 28, 1, 28]> : memref<64x1x128x1x28x1x28xf16> to memref<1x128x50176xf16>
  %10 = rock.transform %2 by <affine_map<(d0, d1, d2, d3, d4, d5, d6) -> (d0, d1, d2, -d3 + d4, -d5 + d6)> by [<PassThrough ["go", "no", "ko"] at [1, 0, 2] -> ["go", "no", "ko"] at [1, 0, 2]>, <Embed{-1, 1} ["0dot", "0tilda"] at [3, 4] -> ["0o"] at [3]>, <Embed{-1, 1} ["1dot", "1tilda"] at [5, 6] -> ["1o"] at [4]>] bounds = [64, 1, 128, 3, 30, 3, 30] -> [64, 1, 128, 28, 28]> : memref<64x1x128x28x28xf16> to memref<64x1x128x3x30x3x30xf16>
  %11 = rock.transform %10 by <affine_map<(d0, d1, d2, d3, d4, d5, d6) -> (d0, d1, d2, d3, d4 + 1, d5, d6 + 1)> by [<PassThrough ["go", "no", "ko"] at [1, 0, 2] -> ["go", "no", "ko"] at [1, 0, 2]>, <Slice{0, 3, 0, 3} ["0slice", "1slice"] at [3, 5] -> ["0dot", "1dot"] at [3, 5]>, <Slice{1, 29, 1, 29} ["0islice", "1islice"] at [4, 6] -> ["0tilda", "1tilda"] at [4, 6]>] bounds = [64, 1, 128, 3, 28, 3, 28] -> [64, 1, 128, 3, 30, 3, 30]> : memref<64x1x128x3x30x3x30xf16> to memref<64x1x128x3x28x3x28xf16>
  %12 = rock.transform %11 by <affine_map<(d0, d1, d2) -> (d2 floordiv 784, d0, d1 floordiv 9, (d1 mod 9) floordiv 3, (d2 mod 784) floordiv 28, d1 mod 3, d2 mod 28)> by [<PassThrough ["gemmG"] at [0] -> ["go"] at [1]>, <Merge{128, 3, 3} ["gemmK"] at [1] -> ["ko", "0slice", "1slice"] at [2, 3, 5]>, <Merge{64, 28, 28} ["gemmN"] at [2] -> ["no", "0islice", "1islice"] at [0, 4, 6]>] bounds = [1, 1152, 50176] -> [64, 1, 128, 3, 28, 3, 28]> : memref<64x1x128x3x28x3x28xf16> to memref<1x1152x50176xf16>
  %alloc = memref.alloc() : memref<1x128x50176xf32>
  rock.gridwise_gemm_accel(%5, %12, %alloc) storeMethod( set) features =  mfma|dot|atomic_add {arch = "amdgcn-amd-amdhsa:gfx942:sramecc-:xnack--", blockSize = 256 : i32, gridSize = 196 : i32, numCU = 228 : i32, params = #rock.xdlops_gemm_derived_params<kpackPerBlock = 8, mPerBlock = 128, nPerBlock = 256, kpack = 4, mPerWave = 64, nPerWave = 128, mnPerXdl = 32, splitKFactor = 1, forceUnroll = true>} : memref<1x1152x128xf16>, memref<1x1152x50176xf16>, memref<1x128x50176xf32>
  linalg.generic {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d1, d2)>, affine_map<(d0, d1, d2) -> (d0, d1, d2)>], iterator_types = ["parallel", "parallel", "parallel"]} ins(%alloc : memref<1x128x50176xf32>) outs(%9 : memref<1x128x50176xf16>) attrs =  {rock.majorTensorNumber = 1 : index} {
  ^bb0(%in: f32, %out: f16):
    %13 = arith.truncf %in : f32 to f16
    linalg.yield %13 : f16
  }
  return
}