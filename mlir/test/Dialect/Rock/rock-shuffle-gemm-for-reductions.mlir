// RUN: rocmlir-opt -rock-shuffle-gemm-for-reductions -mlir-print-local-scope -rock-gemm-to-gridwise %s | FileCheck %s

// CHECK-LABEL: @mlir_convolution_multi_reduce
func.func @mlir_convolution_multi_reduce(%arg0: memref<320xf32>, %arg1: memref<32768xf32>, %arg2: memref<11520xf32>, %arg3: memref<64xf32> {mhal.read_access, rock.prefill = 0.000000e+00 : f32}, %arg4: memref<64xf32>, %arg5: memref<2621440xf32>) attributes {arch = "gfx942:sramecc+:xnack-", block_size = 256 : i32, grid_size = 320 : i32, kernel = "mixr"} {
  %cst = arith.constant 2.44140629E-5 : f32
  %0 = rock.transform %arg0 by <affine_map<(d0, d1, d2, d3, d4) -> (d0 * 10 + d1 + d2 + d3 + d4)> by [<Unmerge{32, 10, 1, 1, 1} ["exp0", "exp1", "exp2", "exp3", "exp4"] at [0, 1, 2, 3, 4] -> ["dim0"] at [0]>] bounds = [32, 10, 1, 1, 1] -> [320]> : memref<320xf32> to memref<32x10x1x1x1xf32>
  %1 = rock.transform %0 by <affine_map<(d0, d1, d2, d3, d4) -> (d1, d2, d3, d4, d0)> by [<PassThrough ["dim4", "dim0", "dim1", "dim2", "dim3"] at [0, 1, 2, 3, 4] -> ["dim4", "dim0", "dim1", "dim2", "dim3"] at [4, 0, 1, 2, 3]>] bounds = [1, 32, 10, 1, 1] -> [32, 10, 1, 1, 1]> : memref<32x10x1x1x1xf32> to memref<1x32x10x1x1xf32>
  %2 = rock.transform %1 by <affine_map<(d0, d1, d2, d3, d4) -> (0, d1, d2, 0, 0)> by [<Broadcast{1} ["dim0"] at [0] -> ["dim0"] at [0]>, <PassThrough ["dim1"] at [1] -> ["dim1"] at [1]>, <PassThrough ["dim2"] at [2] -> ["dim2"] at [2]>, <Broadcast{1} ["dim3"] at [3] -> ["dim3"] at [3]>, <Broadcast{1} ["dim4"] at [4] -> ["dim4"] at [4]>] bounds = [2, 32, 10, 64, 64] -> [1, 32, 10, 1, 1]> : memref<1x32x10x1x1xf32> to memref<2x32x10x64x64xf32>
  %3 = rock.transform %arg2 by <affine_map<(d0, d1, d2, d3) -> (((d0 * 4 + d1) * 3 + d2) * 3 + d3)> by [<Unmerge{320, 4, 3, 3} ["exp0", "exp1", "exp2", "exp3"] at [0, 1, 2, 3] -> ["dim0"] at [0]>] bounds = [320, 4, 3, 3] -> [11520]> : memref<11520xf32> to memref<320x4x3x3xf32>
  %4 = rock.transform %arg1 by <affine_map<(d0, d1, d2, d3) -> (((d0 * 4 + d1) * 64 + d2) * 64 + d3)> by [<Unmerge{2, 4, 64, 64} ["exp0", "exp1", "exp2", "exp3"] at [0, 1, 2, 3] -> ["dim0"] at [0]>] bounds = [2, 4, 64, 64] -> [32768]> : memref<32768xf32> to memref<2x4x64x64xf32>
  %alloc = memref.alloc() : memref<2x32x10x64x64xf32>
  %5 = rock.transform %alloc by <affine_map<(d0, d1, d2, d3) -> (d0, d1 floordiv 10, d1 mod 10, d2, d3)> by [<PassThrough ["dim0"] at [0] -> ["dim0"] at [0]>, <Merge{32, 10} ["dim1"] at [1] -> ["exp1", "exp2"] at [1, 2]>, <PassThrough ["dim2"] at [2] -> ["dim2"] at [3]>, <PassThrough ["dim3"] at [3] -> ["dim3"] at [4]>] bounds = [2, 320, 64, 64] -> [2, 32, 10, 64, 64]> : memref<2x32x10x64x64xf32> to memref<2x320x64x64xf32>
  %6 = rock.transform %4 by <affine_map<(d0, d1, d2, d3, d4) -> (d0, d1 * 4 + d2, d3, d4)> by [<PassThrough ["n", "h", "w"] at [0, 3, 4] -> ["n", "h", "w"] at [0, 2, 3]>, <Unmerge{1, 4} ["g", "c"] at [1, 2] -> ["c"] at [1]>] bounds = [2, 1, 4, 64, 64] -> [2, 4, 64, 64]> : memref<2x4x64x64xf32> to memref<2x1x4x64x64xf32>
  %7 = rock.transform %3 by <affine_map<(d0, d1, d2, d3, d4) -> (d0 * 320 + d1, d2, d3, d4)> by [<PassThrough ["c", "y", "x"] at [2, 3, 4] -> ["c", "y", "x"] at [1, 2, 3]>, <Unmerge{1, 320} ["g", "k"] at [0, 1] -> ["k"] at [0]>] bounds = [1, 320, 4, 3, 3] -> [320, 4, 3, 3]> : memref<320x4x3x3xf32> to memref<1x320x4x3x3xf32>
  %8 = rock.transform %5 by <affine_map<(d0, d1, d2, d3, d4) -> (d0, d1 * 320 + d2, d3, d4)> by [<PassThrough ["n", "h", "w"] at [0, 3, 4] -> ["n", "h", "w"] at [0, 2, 3]>, <Unmerge{1, 320} ["g", "k"] at [1, 2] -> ["k"] at [1]>] bounds = [2, 1, 320, 64, 64] -> [2, 320, 64, 64]> : memref<2x320x64x64xf32> to memref<2x1x320x64x64xf32>
  // CHECK: %[[GEMM_IN_A:.+]] = rock.transform %{{.+}} by <affine_map<(d0, d1, d2) -> (d0, d2, d1 floordiv 9, (d1 mod 9) floordiv 3, d1 mod 3)> by [<PassThrough ["gemmG"] at [0] -> ["g"] at [0]>, <Merge{4, 3, 3} ["gemmK"] at [1] -> ["c", "0", "1"] at [2, 3, 4]>, <PassThrough ["gemmM"] at [2] -> ["k"] at [1]>] bounds = [1, 36, 320] -> [1, 320, 4, 3, 3]> : memref<1x320x4x3x3xf32> to memref<1x36x320xf32>
  // CHECK: %[[GEMM_IN_A_TR0:.+]] = rock.transform %[[GEMM_IN_A]] by <affine_map<(d0, d1, d2, d3) -> (d0, d1, d2 * 10 + d3)> by [<PassThrough ["G", "K"] at [0, 1] -> ["G", "K"] at [0, 1]>, <Unmerge{32, 10} ["d_nr0", "d_r0"] at [2, 3] -> ["M"] at [2]>] bounds = [1, 36, 32, 10] -> [1, 36, 320]> : memref<1x36x320xf32> to memref<1x36x32x10xf32>
  // CHECK: %[[GEMM_IN_A_TR1:.+]] = rock.transform %[[GEMM_IN_A_TR0]] by <affine_map<(d0, d1, d2, d3) -> (d0, d1, d2, d3)> by [<PassThrough ["G", "K"] at [0, 1] -> ["G", "K"] at [0, 1]>, <Merge{32} ["d_nr"] at [2] -> ["d_nr0"] at [2]>, <Merge{10} ["d_r"] at [3] -> ["d_r0"] at [3]>] bounds = [1, 36, 32, 10] -> [1, 36, 32, 10]> : memref<1x36x32x10xf32> to memref<1x36x32x10xf32>
  // CHECK: %[[GEMM_IN_A_TR2:.+]] = rock.transform %[[GEMM_IN_A_TR1]] by <affine_map<(d0, d1, d2, d3, d4) -> (d0, d1, d3, d2 * 2 + d4)> by [<PassThrough ["G", "K", "d_nr"] at [0, 1, 3] -> ["G", "K", "d_nr"] at [0, 1, 2]>, <Unmerge{5, 2} ["d_rh", "d_rl"] at [2, 4] -> ["d_r"] at [3]>] bounds = [1, 36, 5, 32, 2] -> [1, 36, 32, 10]> : memref<1x36x32x10xf32> to memref<1x36x5x32x2xf32>
  // CHECK: %[[GEMM_IN_A_TR3:.+]] = rock.transform %[[GEMM_IN_A_TR2]] by <affine_map<(d0, d1, d2) -> (d0, d1, d2 floordiv 64, (d2 mod 64) floordiv 2, d2 mod 2)> by [<PassThrough ["G", "K"] at [0, 1] -> ["G", "K"] at [0, 1]>, <Merge{5, 32, 2} ["d"] at [2] -> ["d_rh", "d_nr", "d_rl"] at [2, 3, 4]>] bounds = [1, 36, 320] -> [1, 36, 5, 32, 2]> : memref<1x36x5x32x2xf32> to memref<1x36x320xf32>
  %9 = rock.transform %7 by <affine_map<(d0, d1, d2) -> (d0, d2, d1 floordiv 9, (d1 mod 9) floordiv 3, d1 mod 3)> by [<PassThrough ["gemmG"] at [0] -> ["g"] at [0]>, <Merge{4, 3, 3} ["gemmK"] at [1] -> ["c", "0", "1"] at [2, 3, 4]>, <PassThrough ["gemmM"] at [2] -> ["k"] at [1]>] bounds = [1, 36, 320] -> [1, 320, 4, 3, 3]> : memref<1x320x4x3x3xf32> to memref<1x36x320xf32>
  %10 = rock.transform %6 by <affine_map<(d0, d1, d2, d3, d4) -> (d0, d1, d2, d3 - 1, d4 - 1)> by [<PassThrough ["ni"] at [0] -> ["ni"] at [0]>, <PassThrough ["gi"] at [1] -> ["gi"] at [1]>, <PassThrough ["ci"] at [2] -> ["ci"] at [2]>, <Pad{1, 1, 1, 1} ["0ipad", "1ipad"] at [3, 4] -> ["0i", "1i"] at [3, 4]>] bounds = [2, 1, 4, 66, 66] -> [2, 1, 4, 64, 64]> : memref<2x1x4x64x64xf32> to memref<2x1x4x66x66xf32>
  %11 = rock.transform %10 by <affine_map<(d0, d1, d2, d3, d4, d5, d6) -> (d0, d1, d2, d3 + d4, d5 + d6)> by [<PassThrough ["ni", "gi", "ci"] at [0, 1, 2] -> ["ni", "gi", "ci"] at [0, 1, 2]>, <Embed{1, 1} ["0", "0o"] at [3, 4] -> ["0ipad"] at [3]>, <Embed{1, 1} ["1", "1o"] at [5, 6] -> ["1ipad"] at [4]>] bounds = [2, 1, 4, 3, 64, 3, 64] -> [2, 1, 4, 66, 66]> : memref<2x1x4x66x66xf32> to memref<2x1x4x3x64x3x64xf32>
  // CHECK: %[[GEMM_IN_B:.+]] = rock.transform %{{.+}} by <affine_map<(d0, d1, d2) -> (d2 floordiv 4096, d0, d1 floordiv 9, (d1 mod 9) floordiv 3, (d2 mod 4096) floordiv 64, d1 mod 3, d2 mod 64)> by [<PassThrough ["gemmG"] at [0] -> ["gi"] at [1]>, <Merge{4, 3, 3} ["gemmK"] at [1] -> ["ci", "0", "1"] at [2, 3, 5]>, <Merge{2, 64, 64} ["gemmN"] at [2] -> ["ni", "0o", "1o"] at [0, 4, 6]>] bounds = [1, 36, 8192] -> [2, 1, 4, 3, 64, 3, 64]> : memref<2x1x4x3x64x3x64xf32> to memref<1x36x8192xf32>
  // CHECK: %[[GEMM_IN_B_TR0:.+]] = rock.transform %[[GEMM_IN_B]] by <affine_map<(d0, d1, d2, d3, d4, d5) -> (d0, d1, (d2 * 64 + d3 + d4) * 64 + d5)> by [<PassThrough ["G", "K"] at [0, 1] -> ["G", "K"] at [0, 1]>, <Unmerge{2, 64, 1, 64} ["d_nr0", "d_r0", "d_nr1", "d_r1"] at [2, 3, 4, 5] -> ["N"] at [2]>] bounds = [1, 36, 2, 64, 1, 64] -> [1, 36, 8192]> : memref<1x36x8192xf32> to memref<1x36x2x64x1x64xf32>
  // CHECK: %[[GEMM_IN_B_TR1:.+]] = rock.transform %[[GEMM_IN_B_TR0]] by <affine_map<(d0, d1, d2, d3) -> (d0, d1, d2, d3 floordiv 64, 0, d3 mod 64)> by [<PassThrough ["G", "K"] at [0, 1] -> ["G", "K"] at [0, 1]>, <Merge{2, 1} ["d_nr"] at [2] -> ["d_nr0", "d_nr1"] at [2, 4]>, <Merge{64, 64} ["d_r"] at [3] -> ["d_r0", "d_r1"] at [3, 5]>] bounds = [1, 36, 2, 4096] -> [1, 36, 2, 64, 1, 64]> : memref<1x36x2x64x1x64xf32> to memref<1x36x2x4096xf32>
  // CHECK: %[[GEMM_IN_B_TR2:.+]] = rock.transform %[[GEMM_IN_B_TR1]] by <affine_map<(d0, d1, d2, d3, d4) -> (d0, d1, d3, d2 * 128 + d4)> by [<PassThrough ["G", "K", "d_nr"] at [0, 1, 3] -> ["G", "K", "d_nr"] at [0, 1, 2]>, <Unmerge{32, 128} ["d_rh", "d_rl"] at [2, 4] -> ["d_r"] at [3]>] bounds = [1, 36, 32, 2, 128] -> [1, 36, 2, 4096]> : memref<1x36x2x4096xf32> to memref<1x36x32x2x128xf32>
  // CHECK: %[[GEMM_IN_B_TR3:.+]] = rock.transform %[[GEMM_IN_B_TR2]] by <affine_map<(d0, d1, d2) -> (d0, d1, d2 floordiv 256, (d2 mod 256) floordiv 128, d2 mod 128)> by [<PassThrough ["G", "K"] at [0, 1] -> ["G", "K"] at [0, 1]>, <Merge{32, 2, 128} ["d"] at [2] -> ["d_rh", "d_nr", "d_rl"] at [2, 3, 4]>] bounds = [1, 36, 8192] -> [1, 36, 32, 2, 128]> : memref<1x36x32x2x128xf32> to memref<1x36x8192xf32>
  %12 = rock.transform %11 by <affine_map<(d0, d1, d2) -> (d2 floordiv 4096, d0, d1 floordiv 9, (d1 mod 9) floordiv 3, (d2 mod 4096) floordiv 64, d1 mod 3, d2 mod 64)> by [<PassThrough ["gemmG"] at [0] -> ["gi"] at [1]>, <Merge{4, 3, 3} ["gemmK"] at [1] -> ["ci", "0", "1"] at [2, 3, 5]>, <Merge{2, 64, 64} ["gemmN"] at [2] -> ["ni", "0o", "1o"] at [0, 4, 6]>] bounds = [1, 36, 8192] -> [2, 1, 4, 3, 64, 3, 64]> : memref<2x1x4x3x64x3x64xf32> to memref<1x36x8192xf32>
  // CHECK:%[[GEMM_OUT_C:.+]] = rock.transform %{{.+}} by <affine_map<(d0, d1, d2) -> (d2 floordiv 4096, d0, d1, (d2 mod 4096) floordiv 64, d2 mod 64)> by [<PassThrough ["gemmG"] at [0] -> ["go"] at [1]>, <PassThrough ["gemmM"] at [1] -> ["ko"] at [2]>, <Merge{2, 64, 64} ["gemmN"] at [2] -> ["no", "0o", "1o"] at [0, 3, 4]>] bounds = [1, 320, 8192] -> [2, 1, 320, 64, 64]> : memref<2x1x320x64x64xf32> to memref<1x320x8192xf32>
  // CHECK: %[[GEMM_OUT_C_TR0:.+]] = rock.transform %[[GEMM_OUT_C]] by <affine_map<(d0, d1, d2, d3, d4, d5, d6) -> (d0, d1 * 10 + d2, (d3 * 64 + d4 + d5) * 64 + d6)> by [<PassThrough ["G"] at [0] -> ["G"] at [0]>, <Unmerge{32, 10} ["m_nr0", "m_r0"] at [1, 2] -> ["M"] at [1]>, <Unmerge{2, 64, 1, 64} ["n_nr0", "n_r0", "n_nr1", "n_r1"] at [3, 4, 5, 6] -> ["N"] at [2]>] bounds = [1, 32, 10, 2, 64, 1, 64] -> [1, 320, 8192]> : memref<1x320x8192xf32> to memref<1x32x10x2x64x1x64xf32>
  // CHECK: %[[GEMM_OUT_C_TR1:.+]] = rock.transform %[[GEMM_OUT_C_TR0]] by <affine_map<(d0, d1, d2, d3, d4) -> (d0, d1, d2, d3, d4 floordiv 64, 0, d4 mod 64)> by [<PassThrough ["G"] at [0] -> ["G"] at [0]>, <Merge{32} ["m_nr"] at [1] -> ["m_nr0"] at [1]>, <Merge{10} ["m_r"] at [2] -> ["m_r0"] at [2]>, <Merge{2, 1} ["n_nr"] at [3] -> ["n_nr0", "n_nr1"] at [3, 5]>, <Merge{64, 64} ["n_r"] at [4] -> ["n_r0", "n_r1"] at [4, 6]>] bounds = [1, 32, 10, 2, 4096] -> [1, 32, 10, 2, 64, 1, 64]> : memref<1x32x10x2x64x1x64xf32> to memref<1x32x10x2x4096xf32>
  // CHECK: %[[GEMM_OUT_C_TR2:.+]] = rock.transform %[[GEMM_OUT_C_TR1]] by <affine_map<(d0, d1, d2, d3, d4, d5, d6) -> (d0, d2, d1 * 2 + d3, d5, d4 * 128 + d6)> by [<PassThrough ["G"] at [0] -> ["G"] at [0]>, <PassThrough ["m_nr"] at [2] -> ["m_nr"] at [1]>, <Unmerge{5, 2} ["m_rh", "m_rl"] at [1, 3] -> ["m_r"] at [2]>, <PassThrough ["n_nr"] at [5] -> ["n_nr"] at [3]>, <Unmerge{32, 128} ["n_rh", "n_rl"] at [4, 6] -> ["n_r"] at [4]>] bounds = [1, 5, 32, 2, 32, 2, 128] -> [1, 32, 10, 2, 4096]> : memref<1x32x10x2x4096xf32> to memref<1x5x32x2x32x2x128xf32>
  // CHECK: %[[GEMM_OUT_C_TR3:.+]] = rock.transform %[[GEMM_OUT_C_TR2]] by <affine_map<(d0, d1, d2) -> (d0, d1 floordiv 64, (d1 mod 64) floordiv 2, d1 mod 2, d2 floordiv 256, (d2 mod 256) floordiv 128, d2 mod 128)> by [<PassThrough ["G"] at [0] -> ["G"] at [0]>, <Merge{5, 32, 2} ["M"] at [1] -> ["m_rh", "m_nr", "m_rl"] at [1, 2, 3]>, <Merge{32, 2, 128} ["N"] at [2] -> ["n_rh", "n_nr", "n_rl"] at [4, 5, 6]>] bounds = [1, 320, 8192] -> [1, 5, 32, 2, 32, 2, 128]> : memref<1x5x32x2x32x2x128xf32> to memref<1x320x8192xf32>
  %13 = rock.transform %8 by <affine_map<(d0, d1, d2) -> (d2 floordiv 4096, d0, d1, (d2 mod 4096) floordiv 64, d2 mod 64)> by [<PassThrough ["gemmG"] at [0] -> ["go"] at [1]>, <PassThrough ["gemmM"] at [1] -> ["ko"] at [2]>, <Merge{2, 64, 64} ["gemmN"] at [2] -> ["no", "0o", "1o"] at [0, 3, 4]>] bounds = [1, 320, 8192] -> [2, 1, 320, 64, 64]> : memref<2x1x320x64x64xf32> to memref<1x320x8192xf32>
  // CHECK: rock.gridwise_gemm_accel(%[[GEMM_IN_A_TR3]], %[[GEMM_IN_B_TR3]], %[[GEMM_OUT_C_TR3]])
  rock.gridwise_gemm_accel(%9, %12, %13) storeMethod( set) features =  mfma|dot|atomic_add {arch = "gfx942:sramecc+:xnack-", blockSize = 256 : i32, gridSize = 320 : i32, numCU = 228 : i32, params = #rock.xdlops_gemm_derived_params<kpackPerBlock = 4, mPerBlock = 64, nPerBlock = 128, kpack = 1, mPerWave = 64, nPerWave = 32, mnPerXdl = 32, splitKFactor = 1, forceUnroll = true>} : memref<1x36x320xf32>, memref<1x36x8192xf32>, memref<1x320x8192xf32>
  %alloc_0 = memref.alloc() {alignment = 64 : i64} : memref<2x32x10x64x64xf32>
  %alloc_1 = memref.alloc() : memref<2621440xf32>
  %14 = rock.transform %alloc_1 by <affine_map<(d0, d1, d2, d3, d4) -> ((((d0 * 32 + d1) * 10 + d2) * 64 + d3) * 64 + d4)> by [<Unmerge{2, 32, 10, 64, 64} ["col0", "col1", "col2", "col3", "col4"] at [0, 1, 2, 3, 4] -> ["dim0"] at [0]>] bounds = [2, 32, 10, 64, 64] -> [2621440]> : memref<2621440xf32> to memref<2x32x10x64x64xf32>
  %alloc_2 = memref.alloc() : memref<2x32x10x64x64xf32>
  %alloc_3 = memref.alloc() : memref<2x32x10x64x64xf32>
  linalg.generic {indexing_maps = [affine_map<(d0, d1, d2, d3, d4) -> (d0, d1, d2, d3, d4)>, affine_map<(d0, d1, d2, d3, d4) -> (d0, d1, d2, d3, d4)>, affine_map<(d0, d1, d2, d3, d4) -> (d0, d1, d2, d3, d4)>], iterator_types = ["parallel", "parallel", "parallel", "parallel", "parallel"]} ins(%alloc, %2 : memref<2x32x10x64x64xf32>, memref<2x32x10x64x64xf32>) outs(%alloc_0 : memref<2x32x10x64x64xf32>) attrs =  {rock.majorTensorNumber = 1 : index} {
  ^bb0(%in: f32, %in_8: f32, %out: f32):
    %19 = arith.addf %in, %in_8 : f32
    linalg.yield %19 : f32
  }
  memref.copy %alloc_0, %14 : memref<2x32x10x64x64xf32> to memref<2x32x10x64x64xf32>
  memref.copy %alloc_0, %alloc_2 : memref<2x32x10x64x64xf32> to memref<2x32x10x64x64xf32>
  memref.copy %alloc_0, %alloc_3 : memref<2x32x10x64x64xf32> to memref<2x32x10x64x64xf32>
  %alloc_4 = memref.alloc() : memref<2x32x40960xf32>
  %15 = rock.transform %alloc_4 by <affine_map<(d0, d1, d2, d3, d4) -> (d0, d1, (d2 * 64 + d3) * 64 + d4)> by [<PassThrough ["dim0"] at [0] -> ["dim0"] at [0]>, <PassThrough ["dim1"] at [1] -> ["dim1"] at [1]>, <Unmerge{10, 64, 64} ["col2", "col3", "col4"] at [2, 3, 4] -> ["dim2"] at [2]>] bounds = [2, 32, 10, 64, 64] -> [2, 32, 40960]> : memref<2x32x40960xf32> to memref<2x32x10x64x64xf32>
  linalg.generic {indexing_maps = [affine_map<(d0, d1, d2, d3, d4) -> (d0, d1, d2, d3, d4)>, affine_map<(d0, d1, d2, d3, d4) -> (d0, d1, d2, d3, d4)>], iterator_types = ["parallel", "parallel", "parallel", "parallel", "parallel"]} ins(%alloc_2 : memref<2x32x10x64x64xf32>) outs(%15 : memref<2x32x10x64x64xf32>) attrs =  {rock.majorTensorNumber = 0 : index} {
  ^bb0(%in: f32, %out: f32):
    %19 = arith.mulf %in, %cst : f32
    linalg.yield %19 : f32
  }
  %alloc_5 = memref.alloc() : memref<64xf32>
  %16 = rock.transform %alloc_5 by <affine_map<(d0, d1, d2) -> (d0 * 32 + d1 + d2)> by [<Unmerge{2, 32, 1} ["col0", "col1", "col2"] at [0, 1, 2] -> ["dim0"] at [0]>] bounds = [2, 32, 1] -> [64]> : memref<64xf32> to memref<2x32x1xf32>
  rock.reduce  sum %alloc_4 into %16 features =  mfma|dot|atomic_add {axis = 2 : index, blockSize = 256 : i32, gridSize = 10240 : i32} : memref<2x32x40960xf32> into memref<2x32x1xf32>
  %alloc_6 = memref.alloc() : memref<2x32x40960xf32>
  %17 = rock.transform %alloc_6 by <affine_map<(d0, d1, d2, d3, d4) -> (d0, d1, (d2 * 64 + d3) * 64 + d4)> by [<PassThrough ["dim0"] at [0] -> ["dim0"] at [0]>, <PassThrough ["dim1"] at [1] -> ["dim1"] at [1]>, <Unmerge{10, 64, 64} ["col2", "col3", "col4"] at [2, 3, 4] -> ["dim2"] at [2]>] bounds = [2, 32, 10, 64, 64] -> [2, 32, 40960]> : memref<2x32x40960xf32> to memref<2x32x10x64x64xf32>
  linalg.generic {indexing_maps = [affine_map<(d0, d1, d2, d3, d4) -> (d0, d1, d2, d3, d4)>, affine_map<(d0, d1, d2, d3, d4) -> (d0, d1, d2, d3, d4)>], iterator_types = ["parallel", "parallel", "parallel", "parallel", "parallel"]} ins(%alloc_3 : memref<2x32x10x64x64xf32>) outs(%17 : memref<2x32x10x64x64xf32>) attrs =  {rock.majorTensorNumber = 0 : index} {
  ^bb0(%in: f32, %out: f32):
    %19 = arith.mulf %in, %in : f32
    %20 = arith.mulf %19, %cst : f32
    linalg.yield %20 : f32
  }
  %alloc_7 = memref.alloc() : memref<64xf32>
  %18 = rock.transform %alloc_7 by <affine_map<(d0, d1, d2) -> (d0 * 32 + d1 + d2)> by [<Unmerge{2, 32, 1} ["col0", "col1", "col2"] at [0, 1, 2] -> ["dim0"] at [0]>] bounds = [2, 32, 1] -> [64]> : memref<64xf32> to memref<2x32x1xf32>
  rock.reduce  sum %alloc_6 into %18 features =  mfma|dot|atomic_add {axis = 2 : index, blockSize = 256 : i32, gridSize = 10240 : i32} : memref<2x32x40960xf32> into memref<2x32x1xf32>
  memref.copy %alloc_5, %arg3 : memref<64xf32> to memref<64xf32>
  memref.copy %alloc_7, %arg4 : memref<64xf32> to memref<64xf32>
  memref.copy %alloc_1, %arg5 : memref<2621440xf32> to memref<2621440xf32>
  return
}
