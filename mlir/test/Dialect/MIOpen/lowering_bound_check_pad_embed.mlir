// RUN: mlir-opt  %s -miopen-affine-transform |FileCheck %s
module  {
  func @miopen_test_pad_embed_limits(%arg0: memref<1x64x64x3x3xf32>, %arg1: memref<256x1x64x7x7xf32>, %arg2: memref<256x1x64x7x7xf32>) attributes {kernel = 0 : i32} {
    %0 = miopen.transform(%arg0) {extraPad = "false", gemmK_extra = 0 : i32, gemmM_extra = 0 : i32, gridwise_gemm_argument_position = 0 : i32, layout = [{dimensions = [0 : i32], names = ["gemmG"], source_dimensions = [0 : i32], source_names = ["g"], transformation = "PassThrough"}, {dimensions = [1 : i32], names = ["gemmK"], source_dimensions = [2 : i32, 3 : i32, 4 : i32], source_names = ["c", "y", "x"], transformation = "Unfold"}, {dimensions = [2 : i32], names = ["gemmM"], source_dimensions = [1 : i32], source_names = ["k"], transformation = "PassThrough"}], output_layout = ["gemmG", "gemmK", "gemmM"], source_layout = ["g", "k", "c", "y", "x"]} : memref<1x64x64x3x3xf32> to memref<1x576x64xf32>
    %1 = miopen.transform(%arg1) {extraPad = "false", gemmK_extra = 0 : i32, gemmN_extra = 0 : i32, layout = [{dimensions = [1 : i32], names = ["gi"], source_dimensions = [1 : i32], source_names = ["gi"], transformation = "PassThrough"}, {dimensions = [0 : i32], names = ["ni"], source_dimensions = [0 : i32], source_names = ["ni"], transformation = "PassThrough"}, {dimensions = [2 : i32], names = ["ci"], source_dimensions = [2 : i32], source_names = ["ci"], transformation = "PassThrough"}, {bound_check = [4 : i32],dimensions = [3 : i32, 4 : i32], names = ["hipad", "wipad"], parameters = [1 : i32, 1 : i32, 1 : i32, 1 : i32], source_dimensions = [3 : i32, 4 : i32], source_names = ["hi", "wi"], transformation = "Pad"}], output_layout = ["ni", "gi", "ci", "hipad", "wipad"], source_layout = ["ni", "gi", "ci", "hi", "wi"]} : memref<256x1x64x7x7xf32> to memref<256x1x64x9x9xf32>
    %2 = miopen.transform(%1) {intermediate_layout = ["ni", "gi", "ci", "hipad", "wipad"], layout = [{dimensions = [1 : i32], names = ["gi"], source_dimensions = [1 : i32], source_names = ["gi"], transformation = "PassThrough"}, {dimensions = [0 : i32], names = ["ni"], source_dimensions = [0 : i32], source_names = ["ni"], transformation = "PassThrough"}, {dimensions = [2 : i32], names = ["ci"], source_dimensions = [2 : i32], source_names = ["ci"], transformation = "PassThrough"}, {dimensions = [3 : i32, 4 : i32], names = ["y", "ho"], parameters = [1 : i32, 1 : i32, 1 : i32, 0 : i32], source_dimensions = [3 : i32], source_names = ["hipad"], transformation = "Embed", bound_check = [3 : i32]}, { dimensions = [5 : i32, 6 : i32], names = ["x", "wo"], parameters = [1 : i32, 1 : i32, 1 : i32, 0 : i32], source_dimensions = [4 : i32], source_names = ["wipad"], transformation = "Embed"}], output_layout = ["ni", "gi", "ci", "y", "ho", "x", "wo"]} : memref<256x1x64x9x9xf32> to memref<256x1x64x3x7x3x7xf32>
    %3 = miopen.transform(%2) {gridwise_gemm_argument_position = 1 : i32, intermediate_layout = ["ni", "gi", "ci", "y", "ho", "x", "wo"], layout = [{dimensions = [0 : i32], names = ["gemmG"], source_dimensions = [1 : i32], source_names = ["gi"], transformation = "PassThrough"}, {dimensions = [1 : i32], names = ["gemmK"], source_dimensions = [2 : i32, 3 : i32, 5 : i32], source_names = ["ci", "y", "x"], transformation = "Merge"}, {dimensions = [2 : i32], names = ["gemmN"], source_dimensions = [0 : i32, 4 : i32, 6 : i32], source_names = ["ni", "ho", "wo"], transformation = "Merge"}], output_layout = ["gemmG", "gemmK", "gemmN"]} : memref<256x1x64x3x7x3x7xf32> to memref<1x576x12544xf32>
    %4 = miopen.transform(%arg2) {extraPad = "false", gemmM_extra = 0 : i32, gemmN_extra = 0 : i32, gridwise_gemm_argument_position = 2 : i32, layout = [{dimensions = [0 : i32], names = ["gemmG"], source_dimensions = [1 : i32], source_names = ["go"], transformation = "PassThrough"}, {dimensions = [1 : i32], names = ["gemmM"], source_dimensions = [2 : i32], source_names = ["ko"], transformation = "PassThrough"}, {dimensions = [2 : i32], names = ["gemmN"], source_dimensions = [0 : i32, 3 : i32, 4 : i32], source_names = ["no", "ho", "wo"], transformation = "Merge"}], output_layout = ["gemmG", "gemmM", "gemmN"], source_layout = ["no", "go", "ko", "ho", "wo"]} : memref<256x1x64x7x7xf32> to memref<1x64x12544xf32>
    miopen.gridwise_gemm(%0, %3, %4) {arch = "gfx906", dilations = [1 : i32, 1 : i32], filter_dimension = [1, 64, 64, 3, 3], filter_layout = ["g", "k", "c", "y", "x"], input_dimension = [256, 1, 64, 7, 7], input_layout = ["ni", "gi", "ci", "hi", "wi"], kernel_algorithm = "v4r4", num_cu = 64 : i32, output_dimension = [256, 1, 64, 7, 7], output_layout = ["no", "go", "ko", "ho", "wo"], padding = [[1 : i32, 1 : i32], [1 : i32, 1 : i32]], strides = [1 : i32, 1 : i32]} : memref<1x576x64xf32>, memref<1x576x12544xf32>, memref<1x64x12544xf32>

    return
  }
//CHECK: affine_map<(d0, d1, d2, d3, d4) -> (0, 0, 0, 0, 1)>
//CHECK: affine_map<(d0, d1, d2, d3, d4) -> (0, 0, 0, 1, 1)>
}
