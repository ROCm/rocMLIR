get_property(dialect_libs GLOBAL PROPERTY MLIR_DIALECT_LIBS)
get_property(conversion_libs GLOBAL PROPERTY MLIR_CONVERSION_LIBS)

set(LIBS
  ${dialect_libs}
  ${conversion_libs}
  LLVMAMDGPUAsmParser
  LLVMX86AsmParser
  MLIRAnalysis
  MLIRExecutionEngine
  MLIRMIOpenOps
  MLIRMIOpenPipeline
  MLIRParser
  MLIRPass
  MLIRQuant
  MLIRShape
  MLIRTransforms
  MLIRSupport
  MLIRGPUTransforms
  MLIRTargetLLVMIRExport
  MLIRToLLVMIRTranslationRegistration
  MLIRIR
)

set(CMAKE_BUILD_RPATH ${CMAKE_BUILD_DIR}/external/llvm-project/llvm/lib)

llvm_add_library(MLIRMIOpenThin
PARTIAL_SOURCES_INTENDED

  mlir-miopen-lib.cpp

  LINK_LIBS
  ${LIBS}
  )

add_llvm_executable(mlir-miopen-lib-test
  PARTIAL_SOURCES_INTENDED

  mlir-miopen-lib-test.cpp

  DEPENDS
  MLIRMIOpenThin
  ${LIBS}
)

llvm_update_compile_flags(mlir-miopen-lib-test)
target_link_libraries(mlir-miopen-lib-test PRIVATE MLIRMIOpenThin ${LIBS})
mlir_check_link_libraries(mlir-miopen-lib-test)

install(FILES "Miir.h"
  DESTINATION include)

llvm_canonicalize_cmake_booleans(BUILD_FAT_LIBMLIRMIOPEN)
# Static library target, enabled only when building static libs
if( BUILD_FAT_LIBMLIRMIOPEN )
  function(combine_archives output_archive)
    set(mri_file ${CMAKE_CURRENT_BINARY_DIR}/${output_archive}.mri)
    set(full_output_path ${MLIR_MIOPEN_LIB_DIR}/lib${output_archive}.a)
    set(output_archive_dummy_file ./${output_archive}.dummy.cpp)

    # Step one: construct mri file.
    add_custom_command(OUTPUT ${output_archive_dummy_file}
                       COMMAND if [ -f ${output_archive}.mri ]\; then rm ${output_archive}.mri\; fi
                       COMMAND touch ${output_archive}.mri
                       COMMAND echo "create ${full_output_path}" >> ${output_archive}.mri
                       COMMAND for archive in ${MLIR_MIOPEN_LIB_DIR}/*.a ${LLVM_EXTERNAL_LIB_DIR}/*.a\;
                       do echo "addlib $$archive" >> ${output_archive}.mri \; done
                       COMMAND echo "save" >> ${output_archive}.mri
                       COMMAND echo "end" >> ${output_archive}.mri
                       COMMAND touch ${output_archive_dummy_file}
                       DEPENDS MLIRMIOpenThin)

    # Step two: use mri file to generate the fat library.
    llvm_add_library(${output_archive}
      PARTIAL_SOURCES_INTENDED
      STATIC ${output_archive_dummy_file})
    add_custom_command(TARGET ${output_archive}
                       POST_BUILD
                       COMMAND ${CMAKE_AR} -M < ${mri_file}
                       DEPENDS ${output_archive_dummy_file})
  endfunction(combine_archives)

  combine_archives(MLIRMIOpen)

  add_custom_target(libMLIRMIOpen ALL
    DEPENDS
    MLIRMIOpen
    )

  install(TARGETS MLIRMIOpen
    ARCHIVE DESTINATION lib)

  # Install Miir.h to ${CMAKE_INSTALL_PREFIX}/include/<project-name>-<version>/
  # as part of component libMLIRMIOpen
  set(PACKAGE_DIR MLIRMIOpen)
  install(FILES Miir.h
    DESTINATION include/${PACKAGE_DIR}
    COMPONENT libMLIRMIOpen EXCLUDE_FROM_ALL)

  # Install lib${target_name} as part of ${component_name} and
  # export it to be searchable by find_package()
  #
  # As an example, when CMAKE_INSTALL_PREFIX is set to /a/dummy/ and
  # CMAKE_BUILD_TYPE is set to RelWithDebInfo
  # The following files is generated and installed for MLIRMIOpen
  # /a/dummy/lib/MLIRMIOpen/libMLIRMIOpen.a
  # /a/dummy/lib/cmake/MLIRMIOpen/MLIRMIOpenTargets.cmake
  #   This file is autogenerated by install(EXPORT).
  #   It creates the imported library as a target that can be used by
  #   target_link_libraries()
  # /a/dummy/lib/cmake/MLIRMIOpen/MLIRMIOpenTargets-relwithdebinfo.cmake
  #   This file is autogenerated by install(EXPORT).
  #   It sets the location of the library as a property of the imported target
  # /a/dummy/lib/cmake/MLIRMIOpen/MLIRMIOpenConfig.cmake
  #   This file is generated by configure_package_config_file and is searched
  #   and loaded by find_package(). It includes MLIRMIOpenTargets.cmake and sets
  #   the MLIRMIOpen_INCLUDE_DIR variable, which is used by target_include_directories()
  # /a/dummy/lib/cmake/MLIRMIOpen/MLIRMIOpenConfigVersion.cmake
  #   This file is autogenerated by write_basic_package_version_file and is used by
  #   find_package to implement a package version matching mechanism.
  function(export_target target_name component_name)
    set(export_set ${target_name}Targets)
    set(pkg_config_file ${target_name}Config.cmake)
    set(pkg_version_file ${target_name}ConfigVersion.cmake)
    set(INCLUDE_DIR include/${target_name}/)
    set(LIB_CMAKE_DIR lib/cmake/${target_name}/)

    # Install lib${target_name}.a to ${CMAKE_INSTALL_PREFIX}/lib/<project-name>-<version>/
    # and group it into the ${export-set}
    install(TARGETS ${target_name}
      EXPORT ${export_set}
      ARCHIVE DESTINATION lib/${PACKAGE_DIR}
      COMPONENT ${component_name} EXCLUDE_FROM_ALL)

    # Generate package config and version file
    include(CMakePackageConfigHelpers)
    write_basic_package_version_file(
      "${CMAKE_CURRENT_BINARY_DIR}/${pkg_version_file}"
      VERSION ${CMAKE_PROJECT_VERSION}
      COMPATIBILITY AnyNewerVersion)

    configure_package_config_file(cmake/${pkg_config_file}.in
      "${CMAKE_CURRENT_BINARY_DIR}/${pkg_config_file}"
      INSTALL_DESTINATION lib/cmake/${PACKAGE_DIR}
      PATH_VARS INCLUDE_DIR LIB_CMAKE_DIR)

    # Generate Targets.cmake file for the exoport-set to contain imported targets
    set(ConfigPackageLocation lib/cmake/${PACKAGE_DIR})
    install(EXPORT ${export_set}
      NAMESPACE MLIR::
      DESTINATION ${ConfigPackageLocation}
      COMPONENT ${component_name} EXCLUDE_FROM_ALL)

    # Install package configuration and version files
    install(
      FILES
      "${CMAKE_CURRENT_BINARY_DIR}/${pkg_config_file}"
      "${CMAKE_CURRENT_BINARY_DIR}/${pkg_version_file}"
      DESTINATION ${ConfigPackageLocation}
      COMPONENT ${component_name} EXCLUDE_FROM_ALL)
  endfunction(export_target)

  # Install libMLIRMIOpen.a as part of component libMLIRMIOpen
  # and export it to be searchable by find_package()
  export_target(MLIRMIOpen libMLIRMIOpen)

endif()
