#!/usr/bin/env python3

"""
quickTunerStat.py, script to generate statistics for a given quick tuning 
config generted by quickTunerGen.py. There are two options to "validate" 
results from quickTunerGen.py: using the data generated by quickTunerPreproc.py
and doing a table lookup and running a new tuning loop using rocmlir-tuning-driver



"""
import os
import sys
import argparse
import pandas as pd
import numpy as np
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans
from sklearn.cluster import MiniBatchKMeans
from sklearn import metrics
from sklearn.cluster import DBSCAN
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import silhouette_score
from collections import defaultdict
import matplotlib.pyplot as plt
import seaborn as sns
import faulthandler
import re
import glob

"""
Validator Base Class
"""
class perfConfigValidator(object):
    """
    base class for validators, implement validate() method
    """
    def __init__(self, name=None):
        self.name = name

    def collectGemmConfigs(self, gemm_config_file, comment='#'):
        """
        collect gemm config files given a gemm_config_file
        """
        gemm_list = []
        with open(gemm_config_file, 'r') as f:
            lines = f.readlines()

        for line in lines:
            if comment is not None:
                line = line.split(comment)[0]

            line = line.strip()
            if line:
                gemm_list.append(line)

        return gemm_list

    def orderByGemmType(self, input_file=True, normalize=True):
        """
        Creates a dictionary of dictionaries, key by dtype and then gemm, respectively
        """
        def expandPerfConfigs(df):
            df['PerfConfig'] = df['PerfConfig'].str.split(':').str[1]
            
            tile_params = df['PerfConfig'].str.split(',', expand=True).astype(int)
            
            tile_params.columns = ['M/block', 'N/block', 'K/block', 'M/wave', 'N/wave', 'kPack', 'forceUnroll', 'param8', 'param9']
                
            tile_params = tile_params.drop(['param8','param9'], axis=1)

            tile_params['performance'] = df['NormalizedTFlops']

            tile_params.replace('N/A', np.nan, inplace=True)

            return tile_params
        
        df = pd.read_csv(input_file, sep='\t')

        df_dir = {}

        trans_cols = ['TransA', 'TransB']

        param_cols = [ 'G', 'M', 'N','K']

        df = df.astype({entry: bool for entry in trans_cols})

        df = df.astype({entry: int for entry in param_cols})
        
        cols = trans_cols + param_cols

        type_dict = {dtype: group for dtype, group in df.groupby('DataType')}

        for dtype in type_dict:
            sub_df = type_dict[dtype]
            
            gemm_df = {gemm: expandPerfConfigs(group) for gemm, group in sub_df.groupby(cols)}

            for gemm in gemm_df:
                gemm_tup = tuple(gemm)
            
                if dtype not in df_dir:
                    df_dir[dtype] = {}
                df_dir[dtype][gemm_tup] = gemm_df[gemm]
                
        self.validation_data = df_dir
        return df_dir            

    def readPerfConfig(self, file):
        columns = ['M/block', 'N/block', 'K/block', 'M/wave', 'N/wave', 'kPack', 'forceUnroll']
        try:
            df = pd.read_csv(file_path)
            if df.columns[0].startswith('v:'):
                raise ValueError("Detected prefix, not a header.")
            return df
        except ValueError:
            df = pd.read_csv(file_path, header=None)
            df[0] = df[0].apply(lambda x: x.split(':')[1] if isinstance(x, str) and ':' in x else x)
            df.columns = columns
            return df

        def validateFile(self, input_file, dtype=None):
            """
            Method to validate a perf config file for given type
            """
            raise NotImplementedError()

        def validateDir(self, input_dir):
            """
            Method to validate a set of .qt files
            """
            raise NotImplementedError()
            

class dataValidator(perfConfigValidator):
    """
    uses already provided data to validate the configs generated
    """
    def __init__(self, gemm_config_file, preproc_file):
        super().__init__()
        self.gemm_configs = super().collectGemmConfigs(gemm_config_file)
        self.gemm_keys = [self.__gemmConfigToKey(gemm) for gemm in self.gemm_configs]
        self.preproc_file = preproc_file
        self.validation_data = super().orderByGemmType(self.preproc_file)

    def __typeQtMap(self, input_dir):
        """
        creates a dictionary keyed by qt type with values being
        list of matching qt files
        """        
        qt_files = glob.glob(os.path.join(input_dir, "*.qt"))
        file_dict = {}

        for file in qt_files:
            file_split = os.path.basename(file).split('.')
            file_type = file_split[1]
            method = file_split[0]
            
            if method not in file_dict:
                file_dict[method] = {}
            file_dict[method][file_type] = pd.read_csv(file)
            

        return file_dict

    def __gemmConfigToKey(self, gemm_config):
        """
        Convert gemm line to code
        """
        pattern = r'-transA (\S+) -transB (\S+) -g (\d+) -m (\d+) -n (\d+) -k (\d+)'

        match = re.search(pattern, gemm_config)

        if match:
            tup = match.groups()
            transA = True if tup[0].lower() == 'true' else False
            transB = True if tup[1].lower() == 'true' else False
            return (transA, transB) + tuple([int(x) for x in tup[2:]])
        else:
            print("Could not parse gemmConfig", file=sys.stderr)
            exit(1)
        
        return file_name

    def compare(self, results, dtype):
        all_data = []
        columns = ['M/block', 'N/block', 'K/block', 'M/wave', 'N/wave', 'kPack', 'forceUnroll']
        for gemm in self.gemm_keys:
            gemm = self.__gemmConfigToKey(gemm)
            data_subset = self.validation_data[dtype][gemm]
            results = results[list(columns)]
            merged_df = pd.merge(results, data_subset, on=['M/block', 'N/block', 'K/block', 'M/wave', 'N/wave', 'kPack', 'forceUnroll'], how='left')
            all_data.append(merged_df)

    def validateDir(self, input_dir):
        """
        process whole directory
        """
        quick_tune_data = self.__typeQtMap(input_dir)
        
        output_dict = {}
        for method in quick_tune_data:
            print(f"method {method}")
            for dtype in quick_tune_data[method]:
                print(f"dtype {dtype}")
                if dtype not in output_dict:
                    output_dict[dtype] = {}
                print(f"quick_tune_data {quick_tune_data[method][dtype]}")
                gemm_data = self.validate(quick_tune_data[method][dtype], dtype)
                output_dict[dtype][method] = gemm_data
                """
                ct = 0
                max_values = []
                threshold = 0.92
                for df in gemm_data:
                if (df['performance'].dropna() <= threshold).all():
                #print(f"{name} does not meet threshold (>0.8): {df}")
                    ct += 1
                    #max_values.append(df[column].max())
                output_dict[dtype][method] = ct
            
                self.output_df = pd.DataFrame(output_dict)
                print(self.output_df)
                """

        return output_dict
        

    def validateFile(self, input_file, dtype=None):
        """
        process single file, if type passed in then we read perf config file
        """
        if not dtype:
            dtype = os.path.basename(input_file).split('.')[1]
            
        df = super().readPerfConfig(input_file)
        return self.validate(df, dtype)        
    
    def validate(self, file_data, dtype):
        # to validate file we need data already read,

        all_data = []
        columns = ['M/block', 'N/block', 'K/block', 'M/wave', 'N/wave', 'kPack', 'forceUnroll']
        for gemm in self.gemm_keys:
            data_subset = self.validation_data[dtype][gemm]
            file_data = file_data[columns]
            merged_df = pd.merge(file_data, data_subset, on=['M/block', 'N/block', 'K/block', 'M/wave', 'N/wave', 'kPack', 'forceUnroll'], how='left')
            all_data.append(merged_df)

        return all_data
        
                    


def main(args=None):
    if args is None:
        args = sys.argv[1:]

    parser = argparse.ArgumentParser(prog='quickTunerStat.py',
                                     description='Generated statistics and verify quick tuning configs')

    parser.add_argument('--input-dir',
                        type=str,
                        help='Directory of config files generated by quickTuner')


    parser.add_argument('--qt-file',
                        type=str,
                        help='methodname_type.qt file')

    parser.add_argument('--perfconfig-file',
                        type=str,
                        help='Perf config formatted file')

    parser.add_argument('--dtype',
                        choices=['f32', 'f16', 'i8'],
                        type=str,
                        help='Datatype to be used with perfconfig file (required when --perfconfig-file is specified')

    parser.add_argument('--gemm-configs',
                        type=str,
                        required=True,
                        help='File path for gemm-configs')

    parser.add_argument('--data',
                        type=str,
                        required=True,
                        help='File path for datafile from quickTunerPreproc.py')

    parser.add_argument('--method',
                        choices=['data', 'tuner'],
                        default='data',
                        type=str,
                        help='Method for testing the produced files')
    


    pargs = parser.parse_args()

    

    # if single file
    if pargs.input_dir:
        if pargs.method == 'data':
            verifier = dataValidator(pargs.gemm_configs,
                                     pargs.data)
        elif method == 'tuner':
            #method_list.append(tunerValidator(pargs.input_dir,
            #                                 pargs.gemm_configs,
            #                                 pargs.data))
            raise NotImplementedError()

        else:
            raise ValueError(f"Not a valid method: {method}")                                   

        verifier.validateDir(pargs.input_dir)
    elif pargs.qt_file:
        verifier = dataValidator(pargs.gemm_configs, pargs.data)
        verifier.validateFile(pargs.qt_file)
    elif pargs.perf_config_file:
        if not pargs.type:
            raise Exception(f"type not passed with perf config formatted file: {pargs.perf_config_file}")
        verifier = dataValidator(pargs.gemm_configs, pargs.data)
        verifier.validateFile(pargs.qt_file, pargs.dtype)
    
        
if __name__ == '__main__':
    main(sys.argv[1:])
