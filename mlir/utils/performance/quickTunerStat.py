#!/usr/bin/env python3

"""
quickTunerStat.py, script to generate statistics for a given quick tuning 
config generted by quickTunerGen.py. There are two options to "validate" 
results from quickTunerGen.py: using the data generated by quickTunerPreproc.py
and doing a table lookup and running a new tuning loop using rocmlir-tuning-driver



"""
import os
import sys
import argparse
import pandas as pd
import numpy as np
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans
from sklearn.cluster import MiniBatchKMeans
from sklearn import metrics
from sklearn.cluster import DBSCAN
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import silhouette_score
from collections import defaultdict
import matplotlib.pyplot as plt
import seaborn as sns
import faulthandler
import re
import glob

"""
Validator Base Class
"""
class perfConfigValidator(object):
    """
    base class for validators, implement validate() method
    """
    def __init__(self, name=None):
        self.name = name

    def collectGemmConfigs(self, gemm_config_file, comment='#'):
        """
        collect gemm config files given a gemm_config_file
        """
        gemm_list = []
        with open(gemm_config_file, 'r') as f:
            lines = f.readlines()

        for line in lines:
            if comment is not None:
                line = line.split(comment)[0]

            line = line.strip()
            if line:
                gemm_list.append(line)

        return gemm_list

    def orderByGemmType(self, input_file=True, normalize=True):
        """
        Creates a dictionary of dictionaries, key by dtype and then gemm, respectively
        """
        def expandPerfConfigs(df):
            df['PerfConfig'] = df['PerfConfig'].str.split(':').str[1]
            
            tile_params = df['PerfConfig'].str.split(',', expand=True).astype(int)
            
            tile_params.columns = ['M/block', 'N/block', 'K/block', 'M/wave', 'N/wave', 'kPack', 'forceUnroll', 'param8', 'param9']#= ['param1', 'param2', 'param3', 'param4', 'param5', 'param6', 'param7', 'param8', 'param9']
                
            tile_params = tile_params.drop(['param8','param9'], axis=1)

            tile_params['performance'] = df['NormalizedTFlops']

            tile_params.replace('N/A', np.nan, inplace=True)

            return tile_params
        
        df = pd.read_csv(input_file, sep='\t')

        df_dir = {}

        trans_cols = ['TransA', 'TransB']

        param_cols = [ 'G', 'M', 'N','K']

        df = df.astype({entry: bool for entry in trans_cols})

        df = df.astype({entry: int for entry in param_cols})
        
        cols = trans_cols + param_cols

        type_dict = {dtype: group for dtype, group in df.groupby('DataType')}

        for dtype in type_dict:
            sub_df = type_dict[dtype]
            
            gemm_df = {gemm: expandPerfConfigs(group) for gemm, group in sub_df.groupby(cols)}

            for gemm in gemm_df:
                print(gemm)
                gemm_tup = tuple(gemm)
            
                if dtype not in df_dir:
                    df_dir[dtype] = {}
                    df_dir[dtype][gemm_tup] = gemm_df[gemm]
                else:
                    df_dir[dtype][gemm_tup] = gemm_df[gemm]

        return df_dir            


    def __typeQtMap(self, qt_dict):
        raise NotImplementedError()
    
    def validate(self, results):
        """
        return a dictionary of dictionaries
        """
        raise NotImplementedError()

    def getBest(self):
        """
        get the best
        """
        raise NotImplementedError()

class dataValidator(perfConfigValidator):
    """
    uses already provided data to validate the configs generated
    """
    def __init__(self, input_dir, gemm_config_file):
        super().__init__()
        self.gemm_configs = super().collectGemmConfigs(gemm_config_file)
        self.validation_data = orderByGemmType(input_dir, True)        


    def __gemmConfigToKey(self, gemm_config):
        """
        Convert gemm line to code
        """
        pattern = r'-transA (\S+) -transB (\S+) -g (\d+) -m (\d+) -n (\d+) -k (\d+)'

        match = re.search(pattern, gemm_config)

        if match:
            tup = match.groups()
            transA = True if tup[0].lower() == 'true' else False
            transB = True if tup[1].lower() == 'true' else False
            return (transA, transB) + tuple([int(x) for x in tup[2:]])
            g = match.group(3)
            m = match.group(4)
            n = match.group(5)
            k = match.group(6)
            file_name = f"g{g}_m{m}_n{n}_k{k}"
        else:
            print("Could not parse gemmConfig", file=sys.stderr)
            exit(1)
        
        return file_name


    def validate(self, results, dtype):
        all_data = []
        columns = ['M/block', 'N/block', 'K/block', 'M/wave', 'N/wave', 'kPack', 'forceUnroll']
        for gemm in self.gemm_configs:
            gemm = self.__gemmConfigToKey(gemm)
            data_subset = self.validation_data[dtype][gemm]
            results = results[list(columns)]
            merged_df = pd.merge(results, data_subset, on=['M/block', 'N/block', 'K/block', 'M/wave', 'N/wave', 'kPack', 'forceUnroll'], how='left')
            all_data.append(merged_df)
        return all_data
            
    

class quickTunerMethod(object):
    """
    base class for creating quick tuner methods, implement the getConfig() method.
    """
    def __init__(self, name=None):
        self.N = 40
        self.config = None
        if name is None:
            self.name = self.__class__.__name__
        else:
            self.name = name
            

    def setN(self, N):
        """
        To set the current N count (number of configs)
        """
        self.N = N

    def saveQt(self, name=None, debug=False, suffix=".qt"):
        """
        Function to convert a type dictionary config to a .qt file
        Converts the list of quickTuning sets into a group of files
        """
        type_df = self.config
        if name is None:
            name = self.name
        if debug:
            print(filename + suffix)
            printConfigDict(type_df)
        for t in type_df:
            fname = name + "." + t + suffix
            df = type_df[t]
            if 'performance' in df.columns:
                df = df.drop(labels=['performance'], axis=1)
            df = df.to_csv(fname, index=False)

    def savePerfConfig(self, name=None,  dtype=None, prefix="v2:"):
        """
        """
        
        type_df = self.config
        if name is None:
            name = self.name

        if dtype:
            with open(name, 'w') as f:
                for _, row in type_df[dtype].iterrows():
                    tup = tuple(row)
                    s = prefix+",".join(map(str,tup))
                    f.write(s)
                    f.write("\n")
                
        else:
            for t in type_df:
                with open(f"{name}_{dtype}", 'w') as f:
                    for _, row in type_df[t].iterrows():
                        tup = tuple(row)
                        s = prefix+",".join(map(str,tup))
                        f.write(s)
                        f.write("\n")
                    
                

    def getConfig(self, input_dir):
        """
        produces a config that can be converted to .qt file using
        convertToConfig
        """
        raise NotImplementedError()


class quickTuner(object):
    """
    quickTuner class to run quick tuning methods from, requires user to instantiate quickTuner object
    then register quickTunerMethod child classes, finally run tune()
    """
    def __init__(self, pargs):
        self.methods = {}
        self.input_dir = pargs.input_dir
        self.__parseValidationArgs(pargs)

    def __parseValidationArgs(self, pargs):
        """
        parses pargs.validate string for validator
        """
        kwargs = {}
        for item in pargs.vargs:
            if '=' in item:
                k, v = item.split('=', 1)
                kwargs[k] = v
            else:
                raise ValueError(f"Argument {item} is not a valid key=value pair")

        if pargs.validate == 'data':
            # init validator
            self.validator = dataValidator(pargs.input_dir,**kwargs)
        else:
            self.validator = None               
        
    def updateInputDir(self, input_dir):
        self.input_dir = input_dir

    def addMethod(self, method: quickTunerMethod):
        """
        Adds method to method dict
        """
        self.methods[method.name] = method

    def tune(self):
        self.method_results = {}
        if not self.methods:
            print("No methods are registered, use quickTuner.addMethod(method: quickTunerMethod), to add a method", file=sys.stderr)
            exit(1)
        else:
            for k in self.methods:
                method = self.methods[k]
                df = method.getConfig(self.input_dir)
                self.method_results[k] = df

    def validate(self):
        """
        Validate on either a dataset or by running rocmlir-tuning-gen
        
        """
        if self.validator is None:
            print("validator not set", file=sys.stderr)
            return
        output_dict = {}
        for method in self.method_results:
            # df will be of the form: {type1: [data], type2: [data], ..., typeN: [data]}
            for dtype in self.method_results[method]:
                if dtype not in output_dict:
                    output_dict[dtype] = {}
                gemm_data = self.validator.validate(self.method_results[method][dtype], dtype)

                
                for df in gemm_data: # for every gemm config we get data back
                    ct = 0
                    max_values = []
                    threshold = 0.92
                    for df in gemm_data:
                        if (df['performance'].dropna() <= threshold).all():
                            #print(f"{name} does not meet threshold (>0.8): {df}")
                            ct += 1
                            #max_values.append(df[column].max())
                    output_dict[dtype][method] = ct
            
        self.output_df = pd.DataFrame(output_dict)
        print(self.output_df)
        
    
    def saveConfigs(self):
        """
        Iterate through methods and save to each file
        """
        for k in self.methods:
            method = self.methods[k]
            method.saveQt()

    def saveBest(self):
        """
        Save the best method
        """
        df = self.output_df
        
        min_values = df.min()
        best_methods = df.idxmin()

        method_counts = best_methods.value_counts()
        
        max_count = method_counts.max()
        majority_methods = method_counts[method_counts == max_count].index

        result_methods = {}
        for col in df.columns:
            candidates = df.loc[majority_methods, col]
            result_methods[col] = candidates.idxmin()
            
        # Create a list of tuples with index and corresponding method
        output = [(index, method) for index, method in result_methods.items()]

        for entry in output:
            dtype, method = entry
            self.methods[method].savePerfConfig(f"quick_tuning_{dtype}", dtype)                                            


def main(args=None):
    if args is None:
        args = sys.argv[1:]

    parser = argparse.ArgumentParser(prog='quickTunerStat.py',
                                     description='Generated statistics and verify quick tuning configs')

    parser.add_argument('-i', '--input-files',
                        nargs='+',
                        help='List of config files generated by quickTuner')

    parser.add_argument('--gemm-configs',
                        type=str,
                        help='File path for gemm-configs')

    parser.add_argument('--data',
                        type=str,
                        help='File path for datafile from quickTunerPreproc.py')
                     

    pargs = parser.parse_args()

    V = perfConfigValidator()

    V.orderByGemmType(pargs.data)


    
        
if __name__ == '__main__':
    main(sys.argv[1:])
