boolean shouldRunOnMachine(String machine){
    switch (machine){
        case "rocm-framework-38.amd.com":
            return (params.MI200 == true)
        case "sh5-1e707-rf06-26.mkm.dcgpu":
            return (params.MI300 == true)
        case "supermicro-829":
            return (params.Navi2x == true)
        case "aus-navi3x-19.amd.com":
            return (params.Navi3x == true)
        case "navi4x-hw-31.amd.com":
            return (params.Navi4x == true)
    }
}

void buildMIGraphX(String cmakeOpts) {
    dir('AMDMIGraphX') {
        def gpu_targets = sh(script: "/opt/rocm/bin/rocminfo | grep -o -m1 'gfx.*'", returnStdout: true).trim()
        cmakeBuild generator: 'Unix Makefiles',\
            buildDir: 'build',\
            buildType: 'Release',\
            installation: 'InSearchPath',\
            cmakeArgs: """-DMIGRAPHX_ENABLE_MLIR=On
                        -DCMAKE_PREFIX_PATH=/MIGraphXDeps
                        -DCMAKE_CXX_COMPILER=/opt/rocm/llvm/bin/clang++
                        -DGPU_TARGETS=${gpu_targets}
                        ${cmakeOpts}
                        """
        sh 'cd build && make -j $(nproc) driver test_gpu_mlir'
    }
}

void buildMLIR(String target, String cmakeOpts) {
    dir('rocMLIR') {
        cmakeBuild generator: 'Ninja',
            buildDir: 'build',
            buildType: 'RelWithDebInfo',
            installation: 'InSearchPath',
            steps: [[args: target]],
            cmakeArgs: """-DCMAKE_CXX_COMPILER=/opt/rocm/llvm/bin/clang++
                        -DCMAKE_C_COMPILER=/opt/rocm/llvm/bin/clang
                        ${cmakeOpts}"""
        sh 'cd build && cmake --install . --prefix /MIGraphXDeps'
    }
}

void getAndBuildMLIR() {
    dir('rocMLIR') {
        git branch: params.mlir_branch, poll: false,\
            url: 'https://github.com/ROCm/rocMLIR.git'
    }
    buildMLIR("package", "-DBUILD_FAT_LIBROCKCOMPILER=ON")
}

void getAndBuildMIGraphX(String cmakeOpts) {
    dir('AMDMIGraphX') {
        git branch: params.migraphx_branch, poll: false,\
            url: 'https://github.com/ROCm/AMDMIGraphX.git'
    }
    buildMIGraphX(cmakeOpts)
}

String dockerImageCIMIGraphX() {
    return 'rocm/mlir-migraphx-ci:rocm6.2-latest'
}

String dockerArgs() {
    return "--device=/dev/kfd --device=/dev/dri --group-add video --group-add render -v /etc/passwd:/etc/passwd:ro -v /etc/group:/etc/group:ro -v /mnt/nas_share/migraphx/models:/models -u 0"
}

void mountModels() {
    withCredentials([
        usernamePassword(credentialsId: 'model-mounting-credentials', passwordVariable: 'SSHFS_PASS', usernameVariable: 'SSHFS_USER'),
        string(credentialsId: 'sshfs_host', variable: 'SSHFS_HOST'),
        string(credentialsId: 'ssh_public_key', variable: 'SSH_PUBLIC_KEY')
    ]) {

        echo "Setting variables for SSHFS..."
        def sshfsRemotePath = "migraphx/models"
        def sshfsLocalPath = "/mnt/nas_share/migraphx/models"
        def knownHostsFile = "/tmp/known_hosts"

        def knownHostEntry = "${env.SSH_PUBLIC_KEY}"
        if (!fileExists(knownHostsFile) || sh(script: "grep -Fxq '${knownHostEntry}' ${knownHostsFile}", returnStatus: true) != 0) {
            echo "Adding public key to known_hosts..."
            sh "echo '${knownHostEntry}' >> ${knownHostsFile}"
        } else {
            echo "Public key already in known_hosts."
        }

        def isMounted = sh(script: "mount | grep -q '${sshfsLocalPath}'", returnStatus: true) == 0
        if (!isMounted) {
            echo "Directory is not mounted, mounting now..."
            sh """
                sudo mkdir -p '${sshfsLocalPath}'
                sudo sshpass -p '${env.SSHFS_PASS}' sshfs -o ssh_command='ssh -o UserKnownHostsFile=${knownHostsFile}' -o allow_other,ro,debug '${env.SSHFS_USER}@${env.SSHFS_HOST}:${sshfsRemotePath}' '${sshfsLocalPath}' > /dev/null 2>&1 &
            """
        } else {
            echo "Directory ${sshfsLocalPath} is already mounted."
        }
    }
}

def createLogAndSummaryFiles(String arch) {
    def logfile = "${arch}_generic.log"
    def summary = "${arch}_summary.log"

    sh """
    echo "###########################################" >> ${logfile}
    echo "New Run \$(pwd)" >> ${logfile}
    date >> ${logfile}
    echo "GPU: \$(/opt/rocm/bin/rocminfo | grep -o -m 1 'gfx.*')" >> ${logfile}
    echo "MIGX: \$(\$(pwd)/AMDMIGraphX/build/bin/migraphx-driver --version)" >> ${logfile}
    git config --global --add safe.directory \$(pwd)/AMDMIGraphX
    echo "MIGX Commit: \$(git -C \$(pwd)/AMDMIGraphX log -n 1 --pretty=oneline)" >> ${logfile}
    ls -l /etc/alternatives | grep "rocm ->" >> ${logfile}
    echo "###########################################" >> ${logfile}
    """
}

def testModels(modelsToTest, outLogFile, summary, datatypes) {
    modelsToTest.each { testcase ->
        if (testcase.startsWith('#')) {
            return
        }

        datatypes.each { datatype ->
            sh "echo 'Testing(MLIR ENABLED): ${testcase} ${datatype}' >> ${outLogFile}"
            def command = "\$(pwd)/AMDMIGraphX/build/bin/migraphx-driver ${checkFor} ${testcase} ${datatype}"
            def commandOutputFile = "command_output.txt"
            def commandWithTee = "${command} | tee ${commandOutputFile}"
            def timeoutStatus = sh(script: "timeout 1h ${commandWithTee}", returnStatus: true)
            def output = readFile commandOutputFile

            sh(script: "sed -n '/Summary:/,\$p; /FAILED:/,\$p' ${commandOutputFile} | tee -a ${outLogFile}")
            def result = "DONE"

            if (sh(script: "grep -q 'FAILED:' ${commandOutputFile}", returnStatus: true) == 0 ||
                (sh(script: "grep -q 'Summary:' ${commandOutputFile}", returnStatus: true) != 0 && timeoutStatus != 124)) {
                result = "FAILED"
                error "Test case ${testcase} for datatype ${datatype} failed. Stopping execution."
            } else if (timeoutStatus == 124) {
                result = "TIMEOUT"
            }
            sh "echo '${result} Testing(MLIR ENABLED): ${testcase} ${datatype}\n' >> ${outLogFile}"
            sh "echo '(MLIR ENABLED): ${testcase} ${datatype} ${result}' >> ${summary}"
        }
    }
}

void buildAndTest(String arch) {
    def datatypes = []
    if (fp32 == "true") {
        datatypes.add(" ")
    }
    if (fp16 == "true") {
        datatypes.add("--fp16")
    }
    if (int8 == "true") {
        datatypes.add("--int8")
    }

    def tier1P0Models = list_tier1_p0.tokenize('\n')
    def tier1P1Models = list_tier1_p1.tokenize('\n')
    def otherModels = list_others.tokenize('\n')

    try {
        if (enable_tier1_p0 == "true") {
            testModels(tier1P0Models, "${arch}_tier1_p0.log", "${arch}_summary.log",  datatypes)
        }
        if (enable_tier1_p1 == "true") {
            testModels(tier1P1Models, "${arch}_tier1_p1.log", "${arch}_summary.log",  datatypes)
        }
        if (enable_others == "true") {
            testModels(otherModels, "${arch}_other_models.log", "${arch}_summary.log",  datatypes)
        }
    } catch (Exception e) {
        error "Build and Test failed for architecture: ${arch}. Reason: ${e.message}"
    }
}

def list_tier1_p0_default='''\
/models/ORT/bert_base_cased_1.onnx --fill1 input_ids --input-dim @input_ids 1 384 --batch 1
/models/ORT/bert_base_cased_1.onnx --fill1 input_ids --input-dim @input_ids 32 384 --batch 32
/models/ORT/bert_base_cased_1.onnx --fill1 input_ids --input-dim @input_ids 64 384 --batch 64
/models/ORT/bert_base_uncased_1.onnx --fill1 input_ids --input-dim @input_ids 1 384 --batch 1
/models/ORT/bert_base_uncased_1.onnx --fill1 input_ids --input-dim @input_ids 32 384 --batch 32
/models/ORT/bert_base_uncased_1.onnx --fill1 input_ids --input-dim @input_ids 64 384 --batch 64
/models/ORT/bert_large_uncased_1.onnx --fill1 input_ids --input-dim @input_ids 1 384 --batch 1
/models/ORT/bert_large_uncased_1.onnx --fill1 input_ids --input-dim @input_ids 32 384 --batch 32
/models/ORT/bert_large_uncased_1.onnx --fill1 input_ids --input-dim @input_ids 64 384 --batch 64
/models/ORT/distilgpt2_1.onnx --fill1 input_ids --input-dim @input_ids 1 384 --batch 1
/models/ORT/distilgpt2_1.onnx --fill1 input_ids --input-dim @input_ids 32 384 --batch 32
/models/ORT/distilgpt2_1.onnx --fill1 input_ids --input-dim @input_ids 64 384 --batch 64
/models/ORT/onnx_models/bert_base_cased_1_fp16_gpu.onnx --fill1 input_ids --input-dim @input_ids 1 384 --batch 1
/models/ORT/onnx_models/bert_base_cased_1_fp16_gpu.onnx --fill1 input_ids --input-dim @input_ids 32 384 --batch 32
/models/ORT/onnx_models/bert_base_cased_1_fp16_gpu.onnx --fill1 input_ids --input-dim @input_ids 64 384 --batch 64
/models/ORT/onnx_models/bert_large_uncased_1_fp16_gpu.onnx --fill1 input_ids --input-dim @input_ids 1 384 --batch 1
/models/ORT/onnx_models/bert_large_uncased_1_fp16_gpu.onnx --fill1 input_ids --input-dim @input_ids 32 384 --batch 32
/models/ORT/onnx_models/bert_large_uncased_1_fp16_gpu.onnx --fill1 input_ids --input-dim @input_ids 64 384 --batch 64
/models/ORT/onnx_models/distilgpt2_1_fp16_gpu.onnx --fill1 input_ids --input-dim @input_ids 1 384 --batch 1
/models/ORT/onnx_models/distilgpt2_1_fp16_gpu.onnx --fill1 input_ids --input-dim @input_ids 32 384 --batch 32
/models/ORT/onnx_models/distilgpt2_1_fp16_gpu.onnx --fill1 input_ids --input-dim @input_ids 64 384 --batch 64
/models/onnx-model-zoo/gpt2-10.onnx
/models/mlperf/resnet50_v1.onnx
'''

def list_tier1_p1_default= '''\
/models/mlperf/bert_large_mlperf.onnx --fill1 input_ids --fill1 input_ids --fill1 segment_ids --input-dim @input_ids 1 384
/models/mlperf/bert_large_mlperf.onnx --fill1 input_ids --fill1 input_ids --fill1 segment_ids --input-dim @input_ids 64 384
/models/sd21-onnx/text_encoder/model.onnx --input-dim @latent_sample 1 4 64 64 -t 482
/models/sd21-onnx/vae_decoder/model.onnx --input-dim @latent_sample 1 4 64 64 -t 482
/models/sd21-onnx/unet/model.onnx --input-dim @sample 2 4 64 64 @timestep 1 @encoder_hidden_states 2 64 1024
'''

pipeline {
    agent none
    parameters{
        booleanParam(name: 'fp32', defaultValue: true, description: 'No quantization')
        booleanParam(name: 'fp16', defaultValue: true, description: 'Quantize for fp16')
        booleanParam(name: 'int8', defaultValue: true, description: 'Quantize for int8')
        choice(name: 'checkFor', choices:["perf", "verify"], description: 'Do a performance or verification run')
        string(name: 'mlir_branch', defaultValue: 'develop', description: 'Mlir branch to clone.')
        string(name: 'migraphx_branch', defaultValue: 'develop', description: 'MIGraphX branch to clone.')
        booleanParam(name: 'enable_tier1_p0', defaultValue: true, description: 'Enable tests for tier1 P0 models')
        booleanParam(name: 'enable_tier1_p1', defaultValue: true, description: 'Enable tests for tier1 P1 models')
        booleanParam(name: 'enable_others', defaultValue: true, description: 'Enable testing for additional models')
        booleanParam(name: 'MI200', defaultValue: true, description: 'Run the job on a MI200 machine')
        booleanParam(name: 'MI300', defaultValue: true, description: 'Run the job on a MI300 machine')
        booleanParam(name: 'Navi2x', defaultValue: true, description: 'Run the job on a Navi2x machine')
        booleanParam(name: 'Navi3x', defaultValue: true, description: 'Run the job on a Navi3x machine')
        booleanParam(name: 'Navi4x', defaultValue: true, description: 'Run the job on a Navi4x machine')
        text(name: 'list_tier1_p0', defaultValue: list_tier1_p0_default, description: 'List of tier 1 models to test (P0)')
        text(name: 'list_tier1_p1', defaultValue: list_tier1_p1_default, description: 'List of tier 1 models to test (P1)')
        text(name: 'list_others', defaultValue: '', description: 'List of additional models to test')
    }
    stages {
        stage('Environment') {
            matrix {
                axes {
                    axis {
                        name 'PLATFORM'
                        values "rocm-framework-38.amd.com", "sh5-1e707-rf06-26.mkm.dcgpu", "supermicro-829", "aus-navi3x-19.amd.com", "navi4x-hw-31.amd.com"
                    }
                }
                when {
                    beforeAgent true
                    expression { return shouldRunOnMachine("${PLATFORM}") }
                }
                stages {
                    stage('Mount Models') {
                        agent { label "${PLATFORM}" }
                        steps {
                            script {
                                echo "Mounting models on ${PLATFORM}"
                                mountModels()
                            }
                        }
                    }
                }
            }
        }
        stage('Build and Test') {
            matrix {
                axes {
                    axis {
                        name 'PLATFORM'
                        values "rocm-framework-38.amd.com", "sh5-1e707-rf06-26.mkm.dcgpu", "supermicro-829", "aus-navi3x-19.amd.com", "navi4x-hw-31.amd.com"
                    }
                }
                agent {
                    docker {
                        label "${PLATFORM}"
                        image dockerImageCIMIGraphX()
                        args dockerArgs()
                        alwaysPull true
                    }
                }
                when {
                    beforeAgent true
                    expression { return shouldRunOnMachine("${PLATFORM}") }
                }
                stages {
                    stage('Build rocMLIR and MIGraphX' ) {
                        steps {
                            script {
                                getAndBuildMLIR()
                                getAndBuildMIGraphX("")
                            }
                        }
                    }
                    stage('Run Tests') {
                        steps {
                            script {
                                echo "Running tests for ${PLATFORM}"
                                def arch = sh(script: "/opt/rocm/bin/rocminfo | { grep -o -m 1 'gfx.*' || true; } | tr -d '[:space:]'", returnStdout: true).trim()
                                createLogAndSummaryFiles(arch)
                                buildAndTest(arch)
                            }
                        }
                    }
                    stage('Archive Artifacts') {
                        steps {
                            archiveArtifacts allowEmptyArchive: false, artifacts: '*_generic.log,*_tier1_p0.log,*_tier1_p1.log,*_other_models.log,*_summary.log', caseSensitive: true, defaultExcludes: true, fingerprint: false, onlyIfSuccessful: false
                        }
                    }
                }
                post {
                    always {
                        cleanWs()
                    }
                }
            }
        }
    }
}
