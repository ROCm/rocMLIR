//===- transformMapUtils.h - utilities for transform_map ------------===//
//
// Part of the MLIR Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
#ifndef MIOPEN_UTILITY_TRANSFORMMAPUTILS_H
#define MIOPEN_UTILITY_TRANSFORMMAPUTILS_H

#include "mlir/IR/BuiltinAttributes.h"

namespace mlir {
class AffineMap;
class Builder;
class OpBuilder;
class Value;

namespace miopen {
class TransformOp;

/// Unwrap a value from the transforms surrounding it, gathering up the
/// transforms.
/// Given a Value `v` that is generated by
///   %v1 = miopen.transform [#transform1] %v0
///   %v = miopen.transform [#transform2] %v1
/// this method will return %v0 and an ArrayAttr equal to [#transform2,
/// #transform1]. If `existing` is passed in, it must be an array of
/// `TransformMapAttr`s which will be prepended to the returned `ArrayAttr`.

std::tuple<Value, ArrayAttr> untransform(OpBuilder &b, Value transformed,
                                         ArrayAttr existing = nullptr);
std::tuple<Value, ArrayAttr> untransform(OpBuilder &b, Value transformed,
                                         ArrayRef<Attribute> existing);

/// Given an array of transform_maps `transforms` (to be composed left to
/// right), returns the array of dimensions in the lowest space of these
/// transforms that need to be checked for out of bounds stores on the left
/// (checking for indices less than 0) and on the right (indices greater than
/// the dimension on the memref). If initialOob is specified, it is a tuple
/// of out of bounds judgements applicable to the inputs to this transform
/// sequence.
std::tuple<ArrayAttr, ArrayAttr> computeOobFromTransforms(
    Builder &b, ArrayAttr transforms,
    Optional<std::tuple<ArrayAttr, ArrayAttr>> initialOob = llvm::None);

/// Return a `miopen.transform` op that reshapes a given 1D buffer `buffer`
/// into `shape`, using `names` as the names of the reshaped dimensions.
TransformOp reshapeBuffer(OpBuilder &b, Location loc, Value buffer,
                          ArrayRef<StringRef> names, ArrayRef<int64_t> shape);

/// Given an array of TransformMapAttrs `transforms`, a dimension `dim` in
/// the input space of the first transform, and the length `len` of that
/// dimension, returns the largest stride `s` such that length-`s` slices of
/// `dim` correspond to contiguous slices of the underlying memory the
/// `transforms` will be applied to, which is assumed to have shape
/// `outputShape`.
int64_t getMaxVectorization(ArrayAttr transforms, uint32_t dim, int64_t len,
                            ArrayRef<int64_t> outputShape);

/// Get the affine map corresponding to the composition of these affine maps.
/// Returns null when passed an empty array.
AffineMap composeTransforms(ArrayAttr transforms);

} // end namespace miopen
} // end namespace mlir
#endif
