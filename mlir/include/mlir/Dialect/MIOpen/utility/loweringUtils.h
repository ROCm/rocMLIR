//===- loweringUtil.h - functions that often come up during lowering or turing
//---------------===//
//
// Part of the MLIR Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
#ifndef MIOPEN_LOWERING_UTIL_H
#define MIOPEN_LOWERING_UTIL_H

#include "mlir/Dialect/MIOpen/utility/math.h"

#include "mlir/Dialect/MIOpen/MIOpen.h"
#include "mlir/IR/Attributes.h"
#include "mlir/Support/LogicalResult.h"

#include "llvm/ADT/SmallSet.h"
#include "llvm/ADT/SmallVector.h"

using namespace mlir;
using namespace mlir::miopen;

namespace mlir {
namespace miopen {

inline int64_t calculateKBlockNum(int64_t n, int64_t ho, int64_t wo) {
  int64_t gemmK = n * ho * wo;
  int64_t gemmKBlocks = 1;
  if (gemmK % 16 == 0) {
    auto lcm = math_util::lcm(ho * wo, (int64_t)16);
    gemmKBlocks = std::min(gemmK / lcm, n);
  } else if (gemmK % 8 == 0) {
    auto comm = math_util::lcm(ho * wo, (int64_t)8);
    gemmKBlocks = std::min(gemmK / comm, n);
  } else if (gemmK % 4 == 0) {
    auto comm = math_util::lcm(ho * wo, (int64_t)4);
    gemmKBlocks = std::min(gemmK / comm, n);
  }
  // not more than n
  gemmKBlocks = std::min(n, gemmKBlocks);
  // not less than 1
  gemmKBlocks = std::max((__int64_t)1, gemmKBlocks);

  // llvm::errs() << "\n gemmKBlocks: " << gemmKBlocks << " gemmK: " << gemmK
  //               << " ho: " << ho << " wo: " << wo << "\n";
  return gemmKBlocks;
}

/// Unwrap a value from the transforms surrounding it, gathering up the
/// transforms.
/// Given a Value `v` that is generated by
///   %v1 = miopen.transform [#transform1] %v0
///   %v = miopen.transform [#transform2] %v1
/// this method will return %v0 and an ArrayAttr equal to [#transform2,
/// #transform1]. If `existing` is passed in, it must be an array of
/// `TransformMapAttr`s which will be prepended to the returned `ArrayAttr`.

std::tuple<Value, ArrayAttr> untransform(OpBuilder &b, Value transformed,
                                         ArrayAttr existing = nullptr);

inline bool
isEveryPixelWrittenInBackwardData(int64_t strideHeight, int64_t strideWidth,
                                  int64_t dilationHeight, int64_t dilationWidth,
                                  int64_t filterHeight, int64_t filterWidth) {
  bool result = true;
  for (int32_t dim = 0; dim < 2; ++dim) {
    int64_t convStride = (dim == 0) ? strideHeight : strideWidth;
    int64_t convDilation = (dim == 0) ? dilationHeight : dilationWidth;
    int64_t filterSize = (dim == 0) ? filterHeight : filterWidth;

    if (!(convDilation == 1 && convStride <= filterSize))
      result = false;
  }
  return result;
}

inline SmallVector<int64_t>
populateBackwardDataGemmIds(int64_t strideHeight, int64_t strideWidth,
                            int64_t dilationHeight, int64_t dilationWidth,
                            int64_t filterHeight, int64_t filterWidth,
                            bool countZeroInitKernel) {
  int64_t gcdStrideDilationH = math_util::gcd(strideHeight, dilationHeight);
  int64_t gcdStrideDilationW = math_util::gcd(strideWidth, dilationWidth);

  int64_t yTilda = strideHeight / gcdStrideDilationH;
  int64_t xTilda = strideWidth / gcdStrideDilationW;

  int64_t y = filterHeight;
  int64_t x = filterWidth;

  llvm::SmallVector<int64_t> gemmIds;
  bool needZeroInitKernel = false;
  if (countZeroInitKernel) {
    needZeroInitKernel = !isEveryPixelWrittenInBackwardData(
        strideHeight, strideWidth, dilationHeight, dilationWidth, filterHeight,
        filterWidth);
    if (needZeroInitKernel)
      gemmIds.push_back(-1);
  }
  for (int64_t gemmId = 0; gemmId < yTilda * xTilda; ++gemmId) {
    // gemmK size is different for each GEMM
    const int64_t iYTilda = gemmId / xTilda;
    const int64_t iXTilda = gemmId % xTilda;

    int64_t yDotSlice = math_util::integer_divide_ceil(y - iYTilda, yTilda);
    int64_t xDotSlice = math_util::integer_divide_ceil(x - iXTilda, xTilda);
    // gemmK must > 0, otherwise not need to run
    if (yDotSlice * xDotSlice > 0) {
      gemmIds.push_back(gemmId);
    }
  }
  return gemmIds;
}

inline int64_t getGemmId(int64_t strideHeight, int64_t strideWidth,
                         int64_t dilationHeight, int64_t dilationWidth,
                         int64_t filterHeight, int64_t filterWidth,
                         int64_t kernelId) {
  llvm::SmallVector<int64_t> gemmIds = populateBackwardDataGemmIds(
      strideHeight, strideWidth, dilationHeight, dilationWidth, filterHeight,
      filterWidth, /*countZeroInitKernel=*/true);
  assert(gemmIds.size() > static_cast<size_t>(kernelId));
  return gemmIds[kernelId];
}

} // end namespace miopen
} // end namespace mlir
#endif
